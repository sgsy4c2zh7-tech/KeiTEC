<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>SWIFT-TEC v3 – TEC Forecast & Verification Tool (Leaflet版, 4日予報・加算＋Base抽出モデル / NOAA:2時間×12枚)</title>

  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #050816;
      color: #f5f5f5;
    }
    h1, h2, h3 { margin: 0 0 4px 0; letter-spacing: 0.03em; }
    h1 { font-size: 20px; }
    h2 { font-size: 16px; }
    h3 { font-size: 14px; }

    .page { display: flex; height: 100vh; }

    .sidebar {
      width: 430px;
      min-width: 360px;
      max-width: 520px;
      border-right: 1px solid #222b3f;
      padding: 10px;
      overflow-y: auto;
      background: radial-gradient(circle at top, #1c2740 0, #050814 55%, #050814 100%);
    }

    .main {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 10px;
      gap: 8px;
      min-width: 0;
      overflow-y: auto;
    }

    .card {
      background: rgba(10, 16, 32, 0.96);
      border: 1px solid #222b3f;
      border-radius: 8px;
      padding: 8px;
      margin-bottom: 4px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.25);
    }
    .card-header { display:flex; justify-content:space-between; align-items:center; margin-bottom:4px; }
    .card-header span { font-size: 11px; opacity: 0.7; }

    textarea {
      width: 100%;
      min-height: 60px;
      resize: vertical;
      font-size: 11px;
      padding: 4px;
      border-radius: 4px;
      border: 1px solid #334;
      background: #050814;
      color: #f5f5f5;
      font-family: "Consolas","Menlo",monospace;
    }
    input[type="number"], input[type="text"], input[type="color"], select {
      background: #050814;
      border-radius: 4px;
      border: 1px solid #334;
      color: #f5f5f5;
      font-size: 11px;
      padding: 2px 4px;
      font-family: inherit;
    }
    input[type="checkbox"] { transform: scale(0.9); }
    label { font-size: 11px; }

    .row { display:flex; gap:6px; margin-bottom:4px; align-items:center; flex-wrap:wrap; }
    .row > div { flex:1; min-width:80px; }

    button {
      border-radius: 4px;
      border: 1px solid #3b82f6;
      background: #1d4ed8;
      color: #f9fafb;
      padding: 3px 8px;
      font-size: 11px;
      cursor: pointer;
      font-weight: 500;
    }
    button.secondary { border-color:#4b5563; background:#111827; }
    button:disabled { opacity:0.4; cursor:default; }

    .small { font-size: 10px; opacity: 0.85; }

    pre {
      font-size: 11px;
      background: #050814;
      padding: 6px;
      border-radius: 4px;
      border: 1px solid #222b3f;
      white-space: pre-wrap;
    }
    table { width: 100%; border-collapse: collapse; font-size: 10px; }
    th, td { border: 1px solid #222b3f; padding: 2px 4px; text-align: left; }
    th { background: #111827; }

    .flex-col { display:flex; flex-direction:column; gap:4px; }

    .slider-card { flex:0 0 auto; }
    .map-card { flex: 1 1 auto; min-height: 55vh; display:flex; }
    .output-card { flex:0 0 auto; }

    .slider-row {
      display:flex; align-items:center; gap:8px;
      font-size: 11px; flex-wrap: wrap;
    }
    #timeSlider { flex:1; min-width:120px; }

    #tecMap {
      flex:1;
      height:100%;
      min-height:360px;
      border-radius:8px;
      overflow:hidden;
      position:relative;
    }
    .leaflet-container { background:#000; }
    .tec-canvas-overlay {
      position:absolute; top:0; left:0;
      pointer-events:none;
      z-index:400;
    }

    .leaflet-control.tec-legend {
      background: rgba(5, 8, 20, 0.95);
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid #222b3f;
      color: #f5f5f5;
      font-size: 10px;
      line-height: 1.3;
      box-shadow: 0 0 6px rgba(0,0,0,0.5);
    }
    .tec-legend-title { text-align:center; margin-bottom:4px; font-weight:600; letter-spacing:0.05em; }
    .tec-legend-bar { width:18px; height:130px; margin:0 auto 4px auto; border-radius:4px; border:1px solid #444; }
    .tec-legend-labels { display:flex; justify-content:space-between; font-size:9px; }

    .output-row { display:flex; gap:8px; align-items:stretch; flex-wrap:wrap; }
    .output-col { flex:1; min-width:200px; display:flex; flex-direction:column; }
    .output-col pre { max-height:220px; overflow-y:auto; }

    hr { border:none; border-top:1px solid #222b3f; margin:4px 0; }

    .focus-btn { width:100%; font-size:9px; padding:3px 2px; }
    .mono { font-family: "Consolas","Menlo",monospace; }

    .pill {
      display:inline-block;
      font-size:10px;
      padding:1px 6px;
      border:1px solid #334;
      border-radius: 999px;
      background:#050814;
      opacity:0.95;
    }
  </style>

  <!-- パスワード保護 -->
  <script>
    (function () {
      const PASSWORD = "Haneishi";
      const input = prompt("パスワードを入力してください");
      if (input !== PASSWORD) {
        alert("パスワードが違います");
        document.documentElement.innerHTML = "";
        throw new Error("Unauthorized");
      }
    })();
  </script>
</head>

<body>
  <div class="page">
    <!-- ============= サイドバー ============= -->
    <div class="sidebar">
      <div class="card">
        <div class="card-header">
          <h1>SWIFT-TEC v3</h1>
          <span>Global TEC Forecast (4-day, Base抽出＋加算モデル)</span>
        </div>
        <div class="small">
          ・入力TECは <b>BoM</b> or <b>NOAA(GloTEC)</b> を選択<br>
          ・BaseTEC = 入力TEC − Sflare_base − Sstorm_base（逆算）<br>
          ・BaseTEC に ΔStorm(Kp予報) ＋ ΔFlare(Deep Flare Net) を<b>足し算</b><br>
          ・Kp(t) は「予報用」と「Base用」を分離（Base範囲外は予報Kpへ自動フォールバック）<br>
          ・Leaflet 地図で TEC / GPS誤差を確認、地域フォーカスも可能<br>
          ・★NOAA入力は <b>解析前日(UTC)の1日分</b> をAPI取得（<b>2時間おき12枚</b>）→ 2°×5°格子化<br>
          ・★TECはNOAA読み取り時に <b>小数点以下切り捨て</b><br>
          ・★描画は rAF＋投影キャッシュで軽量化（黒い影=dateline折返しrectを補正）
        </div>
      </div>

      <!-- 0. 入力TECソース -->
      <div class="card">
        <div class="card-header">
          <h2>0. 入力TECソース</h2>
          <span>BoM / NOAA</span>
        </div>
        <div class="row">
          <div style="flex:1;">
            <label>TEC入力元</label><br>
            <select id="tecSourceSelect" style="width:100%;">
              <option value="bom">BoM (WorldXXXX_tec.txt 最大9枚)</option>
              <option value="noaa" selected>NOAA (GloTEC: 解析前日UTCの1日分=12枚, 2°×5°へ格子化)</option>
            </select>
          </div>
        </div>

        <div class="row">
          <button onclick="fetchNoaaGloTecPrevDay12_2hour(false)">NOAA 解析前日(UTC) 2時間おき12枚をAPI取得（メモリ保持）</button>
          <button class="secondary" onclick="fetchNoaaGloTecPrevDay12_2hour(true)">取得して保存（概要のみ）</button>
        </div>
        <div class="small" id="noaaTecStatus"></div>

        <div class="small" style="margin-top:6px;">
          <div class="row" style="gap:8px;">
            <span class="pill">NOAA12枚の一覧</span>
            <span class="pill" id="noaa12KeyPill">day: --</span>
          </div>
          <div style="max-height:160px; overflow:auto; border:1px solid #222b3f; border-radius:6px; padding:4px;">
            <table>
              <thead><tr><th>#</th><th>target(UTC)</th><th>file</th></tr></thead>
              <tbody id="noaa12TableBody">
                <tr><td colspan="3" class="small">未取得</td></tr>
              </tbody>
            </table>
          </div>
        </div>

        <div class="small" style="margin-top:6px;">
          ※一覧JSON（geojson_2d_urt.json）から前日(UTC) 00,02,…,22 の近傍ファイルを自動選定。<br>
          ※UIのtextareaはデバッグ9枠だけ表示（予報は12枠を内部使用）。
        </div>
      </div>

      <!-- 1. TEC入力（テキスト貼付/保存用） -->
      <div class="card">
        <div class="card-header">
          <h2>1. TEC入力（テキスト貼付/保存用）</h2>
          <span>BoM or NOAA(デバッグ用9枠)</span>
        </div>

        <div class="small">
          ・BoMの場合：0000/0300/0600/0900/1200/1500/1800/2100/2330 の計9枚<br>
          ・NOAAの場合：ここは<b>デバッグ表示用（先頭9枚）</b><br>
          ・本命のNOAA運用は「0. NOAA 解析前日 12枚」ボタンでメモリに取り込みます
        </div>

        <div class="row">
          <button onclick="fetchBomTec9FromApi(false)">BoM 9枚をAPI取得 → 入力欄へ</button>
          <button class="secondary" onclick="fetchBomTec9FromApi(true)">取得して保存</button>
        </div>
        <div class="small" id="bomApiStatus"></div>

        <hr>

        <div class="row small"><div>Input #1</div><div>Input #2</div><div>Input #3</div></div>
        <div class="row">
          <div><textarea id="bomInput1" placeholder="# (BoM/NOAA)"></textarea></div>
          <div><textarea id="bomInput2"></textarea></div>
          <div><textarea id="bomInput3"></textarea></div>
        </div>
        <div class="row small"><div>Input #4</div><div>Input #5</div><div>Input #6</div></div>
        <div class="row">
          <div><textarea id="bomInput4"></textarea></div>
          <div><textarea id="bomInput5"></textarea></div>
          <div><textarea id="bomInput6"></textarea></div>
        </div>
        <div class="row small"><div>Input #7</div><div>Input #8</div><div>Input #9</div></div>
        <div class="row">
          <div><textarea id="bomInput7"></textarea></div>
          <div><textarea id="bomInput8"></textarea></div>
          <div><textarea id="bomInput9"></textarea></div>
        </div>
        <div class="row">
          <button onclick="saveBomInputs()">入力（BoM/NOAA）を保存</button>
          <button class="secondary" onclick="clearBomInputsStorage()">保存を削除</button>
        </div>
        <div class="small" id="bomInfo">※「入力を保存」を押した時点の内容をブラウザに保存。次回起動時に自動復元。</div>
      </div>

      <!-- 2. NOAA Kp テキスト（予報用） -->
      <div class="card">
        <div class="card-header">
          <h2>2. NOAA Kp テキスト（予報用）</h2>
          <span>3-Day Geomag Forecast</span>
        </div>
        <div class="small">
          ・Kp（3日予報）は、NOAAの <b>3-day geomag forecast (text)</b> を自動取得できます。
        </div>
        <div class="row">
          <button onclick="fetchNoaa3DayGeomagToTextarea()">NOAA 3-day（Kp）をAPI取得 → 貼付</button>
          <span class="small" id="noaa3dayStatus"></span>
        </div>
        <div class="row">
          <div>
            <label>Kp 予報テキスト（NOAA geomag forecast）</label><br>
            <textarea id="noaaKpText" placeholder="自動取得 or 手動貼付"></textarea>
          </div>
        </div>
      </div>

      <!-- 2b. Base作成用 Kp / フレア -->
      <div class="card">
        <div class="card-header">
          <h2>2b. Base 作成用 Kp / フレア</h2>
          <span>入力TECから嵐・フレア成分を引き算</span>
        </div>
        <div class="small">
          ・Base用 Kp：NOAA 実測 Kp の JSON 配列（1日分）を貼付 or API取得<br>
          ・Base用 フレア：NOAA最新 X-ray flare（M/X）をAPI取得して自動入力可能<br>
          ※空の場合：Kp は「予報用」を流用、フレアは 0 とみなす
        </div>

        <div class="row">
          <button onclick="fetchNoaaPlanetaryKIndex1DayToBase()">NOAA K-index（1日分）をAPI取得 → Base用Kpへ</button>
          <span class="small" id="kindexStatus"></span>
        </div>
        <div class="row">
          <button onclick="fetchNoaaXrayFlareLatestToBase()">NOAA 最新X-rayフレア（M/X）をAPI取得 → Base用フレアへ</button>
          <span class="small" id="xrayflareStatus"></span>
        </div>

        <div class="row">
          <div>
            <label>Base 用 Kp（JSON 配列）</label><br>
            <textarea id="baseKpJson" placeholder='[["time_tag","Kp","a_running","station_count"],["2025-11-26 00:00:00.000","3.33","18","8"], ...]'></textarea>
          </div>
        </div>
        <div class="row">
          <div>
            <label>Base 用 フレア（JSON, time / Px / Pm）</label><br>
            <textarea id="baseFlareJson" placeholder='[{"time":"2025-11-26T00:00:00Z","Px":5,"Pm":15}, ...]'></textarea>
          </div>
        </div>
      </div>

      <!-- 3. Deep Flare Net 9領域（予報用） -->
      <div class="card">
        <div class="card-header">
          <h2>3. Deep Flare Net 領域（予報用）</h2>
          <span>9分割フレア確率（3×3）</span>
        </div>
        <div class="small">
          太陽円盤を 3×3 の 9領域に分割し、各領域ごとの Xクラス / Mクラス発生確率 [%] を入力。<br>
          R1=北西, R2=北, R3=北東 / R4=西, R5=中央, R6=東 / R7=南西, R8=南, R9=南東
        </div>
        <table>
          <thead><tr><th>ID</th><th>位置</th><th>P(X≥)%</th><th>P(M≥)%</th><th>使用</th></tr></thead>
          <tbody>
            <tr><td>R1</td><td>北西</td><td><input id="fx1" type="number" value="0" style="width:50px;"></td><td><input id="fm1" type="number" value="10" style="width:50px;"></td><td><input id="fu1" type="checkbox" checked></td></tr>
            <tr><td>R2</td><td>北</td><td><input id="fx2" type="number" value="0" style="width:50px;"></td><td><input id="fm2" type="number" value="10" style="width:50px;"></td><td><input id="fu2" type="checkbox" checked></td></tr>
            <tr><td>R3</td><td>北東</td><td><input id="fx3" type="number" value="0" style="width:50px;"></td><td><input id="fm3" type="number" value="10" style="width:50px;"></td><td><input id="fu3" type="checkbox" checked></td></tr>
            <tr><td>R4</td><td>西</td><td><input id="fx4" type="number" value="0" style="width:50px;"></td><td><input id="fm4" type="number" value="10" style="width:50px;"></td><td><input id="fu4" type="checkbox" checked></td></tr>
            <tr><td>R5</td><td>中央</td><td><input id="fx5" type="number" value="0" style="width:50px;"></td><td><input id="fm5" type="number" value="10" style="width:50px;"></td><td><input id="fu5" type="checkbox" checked></td></tr>
            <tr><td>R6</td><td>東</td><td><input id="fx6" type="number" value="0" style="width:50px;"></td><td><input id="fm6" type="number" value="10" style="width:50px;"></td><td><input id="fu6" type="checkbox" checked></td></tr>
            <tr><td>R7</td><td>南西</td><td><input id="fx7" type="number" value="0" style="width:50px;"></td><td><input id="fm7" type="number" value="10" style="width:50px;"></td><td><input id="fu7" type="checkbox" checked></td></tr>
            <tr><td>R8</td><td>南</td><td><input id="fx8" type="number" value="0" style="width:50px;"></td><td><input id="fm8" type="number" value="10" style="width:50px;"></td><td><input id="fu8" type="checkbox" checked></td></tr>
            <tr><td>R9</td><td>南東</td><td><input id="fx9" type="number" value="0" style="width:50px;"></td><td><input id="fm9" type="number" value="10" style="width:50px;"></td><td><input id="fu9" type="checkbox" checked></td></tr>
          </tbody>
        </table>
      </div>

      <!-- 4. TEC カラーマップ設定 -->
      <div class="card">
        <div class="card-header"><h2>4. TEC カラーマップ設定</h2><span>TEC値 → 色</span></div>
        <div class="small">TEC [TECU] の上限と色を設定。色は地図と凡例に反映。</div>
        <table>
          <thead><tr><th>レベル</th><th>TEC上限</th><th>色</th></tr></thead>
          <tbody>
            <tr><td>L1</td><td><input id="tLimit1" type="number" value="10" style="width:60px;"></td><td><input id="tColor1" type="color" value="#00ff00"></td></tr>
            <tr><td>L2</td><td><input id="tLimit2" type="number" value="30" style="width:60px;"></td><td><input id="tColor2" type="color" value="#ffff00"></td></tr>
            <tr><td>L3</td><td><input id="tLimit3" type="number" value="60" style="width:60px;"></td><td><input id="tColor3" type="color" value="#ff9900"></td></tr>
            <tr><td>L4</td><td><input id="tLimit4" type="number" value="120" style="width:60px;"></td><td><input id="tColor4" type="color" value="#ff0000"></td></tr>
          </tbody>
        </table>
        <div class="row">
          <button onclick="applyTecColorScale()">TEC色を反映</button>
          <button class="secondary" onclick="resetTecColorScale()">初期化</button>
        </div>
      </div>

      <!-- 5. GPS L1誤差 カラーマップ設定 -->
      <div class="card">
        <div class="card-header"><h2>5. GPS L1誤差 カラーマップ</h2><span>誤差[m] → 色</span></div>
        <div class="small">L1即位誤差 [m] の上限と色を設定。TEC×kL1 で換算。</div>
        <table>
          <thead><tr><th>レベル</th><th>誤差上限</th><th>色</th></tr></thead>
          <tbody>
            <tr><td>L1</td><td><input id="gLimit1" type="number" value="5" style="width:60px;"></td><td><input id="gColor1" type="color" value="#00ff00"></td></tr>
            <tr><td>L2</td><td><input id="gLimit2" type="number" value="10" style="width:60px;"></td><td><input id="gColor2" type="color" value="#ffff00"></td></tr>
            <tr><td>L3</td><td><input id="gLimit3" type="number" value="20" style="width:60px;"></td><td><input id="gColor3" type="color" value="#ff9900"></td></tr>
            <tr><td>L4</td><td><input id="gLimit4" type="number" value="40" style="width:60px;"></td><td><input id="gColor4" type="color" value="#ff0000"></td></tr>
          </tbody>
        </table>
        <div class="row">
          <button onclick="applyGpsColorScale()">GPS色を反映</button>
          <button class="secondary" onclick="resetGpsColorScale()">初期化</button>
        </div>
      </div>

      <!-- 6. 係数設定 -->
      <div class="card">
        <div class="card-header"><h2>6. 係数設定（Advanced）</h2><span>Base / Storm / Flare / GPS</span></div>
        <div class="small">※いじり過ぎる前に現在値をどこかにメモ推奨。</div>
        <div class="flex-col">
          <div class="row">
            <div><label>kBase（静穏ベース倍率）</label><br><input id="cfg_kBase" type="number" value="1.0" step="0.1"></div>
            <div><label>kStorm（ΔStorm倍率）</label><br><input id="cfg_kStorm" type="number" value="1.0" step="0.1"></div>
          </div>
          <div class="row">
            <div><label>β_flare</label><br><input id="cfg_betaFlare" type="number" value="0.7" step="0.05"></div>
            <div><label>k_X（Xフレア寄与）</label><br><input id="cfg_kX" type="number" value="1.0" step="0.1"></div>
            <div><label>k_M（Mフレア寄与）</label><br><input id="cfg_kM" type="number" value="0.5" step="0.1"></div>
          </div>
          <div class="row">
            <div><label>kL1（TEC→L1誤差[m/TECU]）</label><br><input id="cfg_kL1" type="number" value="0.16" step="0.01"></div>
          </div>
        </div>
        <div class="row">
          <button onclick="saveConfig()">設定を保存</button>
          <button class="secondary" onclick="loadConfig(true)">保存値を再読込</button>
        </div>
      </div>

      <!-- 7. 地域フォーカス -->
      <div class="card">
        <div class="card-header"><h2>7. 地域フォーカス</h2><span>地図ズーム</span></div>
        <div class="row">
          <button class="focus-btn" onclick="focusRegion('japan')">日本</button>
          <button class="focus-btn" onclick="focusRegion('northAmerica')">北アメリカ</button>
        </div>
        <div class="row">
          <button class="focus-btn" onclick="focusRegion('southAmerica')">南アメリカ</button>
          <button class="focus-btn" onclick="focusRegion('europe')">ヨーロッパ</button>
        </div>
        <div class="row">
          <button class="focus-btn" onclick="focusRegion('africa')">アフリカ</button>
          <button class="focus-btn" onclick="focusRegion('australia')">オーストラリア</button>
        </div>
        <hr>
        <div class="small">手動指定（緯度・経度 範囲）</div>
        <div class="row">
          <div><label>Lat min</label><br><input id="focusLatMin" type="number" value="-10" step="1"></div>
          <div><label>Lat max</label><br><input id="focusLatMax" type="number" value="50" step="1"></div>
        </div>
        <div class="row">
          <div><label>Lon min</label><br><input id="focusLonMin" type="number" value="120" step="1"></div>
          <div><label>Lon max</label><br><input id="focusLonMax" type="number" value="150" step="1"></div>
        </div>
        <div class="row">
          <button class="focus-btn" onclick="applyManualFocus()">手動フォーカス適用</button>
          <button class="focus-btn secondary" onclick="resetFocus()">全体表示</button>
        </div>
      </div>

      <!-- 8. 実行 -->
      <div class="card">
        <div class="card-header"><h2>8. 実行</h2><span>予報 & 描画</span></div>
        <div class="row small">
          <div style="flex:1;">
            予報スタート時刻（UTC）:<br>
            <select id="forecastStartSelect" style="width:100%;"></select>
          </div>
        </div>
        <div class="small" id="forecastStartInfo">
          入力（BoM/NOAA）を読み込むと候補が自動で入ります。未選択時は最も早い有効時刻から開始します。
        </div>
        <div class="row" style="margin-top:4px;">
          <button onclick="runForecast()">TEC予報を計算</button>
          <button class="secondary" onclick="resetAll()">リセット</button>
        </div>
        <div class="row" style="margin-top:4px;">
          <button onclick="exportTecCsv4day()">4日分TECをCSV出力</button>
        </div>
        <div id="runInfo" class="small"></div>
      </div>
    </div>

    <!-- ============= メイン領域 ============= -->
    <div class="main">
      <div class="card slider-card">
        <div class="slider-row">
          <span>時間スライダー（0〜4日 / 30分刻み）</span>
          <input type="range" id="timeSlider" min="0" max="192" value="0" oninput="onSliderChange()">
          <span id="timeLabel">t = 0.0 h</span>
          <span id="utcLabel">UTC: --</span>
          <span id="kpNowLabel">KpF=-- / KpB=--</span>
        </div>
        <div class="row small" style="margin-top:4px;">
          <div style="flex:1;">
            TEC透明度:
            <input id="tecAlpha" type="range" min="0.2" max="1" step="0.05" value="0.8" style="width:140px;" oninput="onTecAlphaChange()">
          </div>
          <div style="flex:1;">
            表示モード:
            <select id="mapModeSelect" onchange="changeMapMode()">
              <option value="tec">TEC [TECU]</option>
              <option value="gps">GPS L1誤差 [m]</option>
            </select>
          </div>
          <div style="flex:2;"><span class="small">※地図をズーム／ドラッグして任意地域の分布を確認できます。</span></div>
        </div>
      </div>

      <div class="card map-card"><div id="tecMap"></div></div>

      <div class="card output-card">
        <div class="output-row">
          <div class="output-col" style="flex:2;">
            <h3>9. 現在の計算式（Base抽出＋加算モデル）</h3>
            <pre id="formulaText">(Base抽出＋ ΔStorm + ΔFlare の式をここに表示)</pre>
          </div>
          <div class="output-col" style="flex:1;">
            <h3>10. 現在の TEC / GPS値</h3>
            <pre id="pointInfo">地図上をクリックすると、その格子点のTEC・GPS L1誤差と位置が表示されます。</pre>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <script>
    /* ============================
     *  画面にJSエラーを出す（デバッグ）
     * ============================ */
    window.addEventListener("error", (ev) => {
      try {
        const msg = (ev && (ev.message || (ev.error && ev.error.message))) ? (ev.message || ev.error.message) : "unknown error";
        const div = document.getElementById("runInfo");
        if (div) div.textContent = "JSエラー: " + msg;
      } catch {}
    });

    /* ============================
     *  API endpoints
     * ============================ */
    const BOM_TEC_BASE_URL = "https://downloads.sws.bom.gov.au/data/Satellite/";
    const BOM_TEC_FILES_9 = [
      "World0000_tec.txt","World0300_tec.txt","World0600_tec.txt","World0900_tec.txt",
      "World1200_tec.txt","World1500_tec.txt","World1800_tec.txt","World2100_tec.txt","World2330_tec.txt"
    ];

    const NOAA_3DAY_GEOMAG_TEXT_URL = "https://services.swpc.noaa.gov/text/3-day-geomag-forecast.txt";
    const NOAA_PLANETARY_K_INDEX_URL = "https://services.swpc.noaa.gov/products/noaa-planetary-k-index.json";
    const NOAA_XRAY_FLARES_LATEST_URL = "https://services.swpc.noaa.gov/json/goes/primary/xray-flares-latest.json";

    const NOAA_GLOTEC_INDEX_URL = "https://services.swpc.noaa.gov/products/glotec/geojson_2d_urt.json";
    const NOAA_GLOTEC_BASE_URL  = "https://services.swpc.noaa.gov/products/glotec/geojson_2d_urt/";

    async function fetchText(url) {
      const res = await fetch(url, { cache: "no-store" });
      if (!res.ok) throw new Error(`HTTP ${res.status} for ${url}`);
      return await res.text();
    }
    async function fetchJson(url) {
      const res = await fetch(url, { cache: "no-store" });
      if (!res.ok) throw new Error(`HTTP ${res.status} for ${url}`);
      return await res.json();
    }
    function setStatus(id, msg) {
      const el = document.getElementById(id);
      if (el) el.textContent = msg || "";
    }

    /* ============================
     *  NOAA 前日(UTC) 2時間おき12枚（メモリ保持）
     * ============================ */
    const NOAA_INPUT_IDS = ["bomInput1","bomInput2","bomInput3","bomInput4","bomInput5","bomInput6","bomInput7","bomInput8","bomInput9"];

    let gNoaaDayFrames = null;  // length=12
    let gNoaaDayTimes  = null;  // Date[12] (target times)
    let gNoaaDayFiles  = null;  // string[12]
    let gNoaaDayKey    = null;  // "YYYY-MM-DD" (UTC)

    // デバッグ9枚
    let gNoaaInputTimes = new Array(9).fill(null);
    let gNoaaInputFiles = new Array(9).fill(null);

    function basename(p) {
      const s = String(p || "");
      const parts = s.split("/");
      return parts[parts.length-1] || s;
    }

    function parseUtcFromFilename(fn) {
      const s = String(fn || "");
      const m = s.match(/(\d{8})T(\d{6})Z/i);
      if (!m) return null;
      const y = parseInt(m[1].slice(0,4),10);
      const mo= parseInt(m[1].slice(4,6),10);
      const d = parseInt(m[1].slice(6,8),10);
      const hh= parseInt(m[2].slice(0,2),10);
      const mm= parseInt(m[2].slice(2,4),10);
      const ss= parseInt(m[2].slice(4,6),10);
      return new Date(Date.UTC(y, mo-1, d, hh, mm, ss));
    }

    function toDayKeyUtc(d) {
      const y = d.getUTCFullYear();
      const m = String(d.getUTCMonth()+1).padStart(2,"0");
      const da= String(d.getUTCDate()).padStart(2,"0");
      return `${y}-${m}-${da}`;
    }

    function normalizeGloTecIndexJson(js) {
      if (Array.isArray(js)) return js;
      if (js && Array.isArray(js.files)) return js.files;
      if (js && Array.isArray(js.data)) return js.data;
      if (js && typeof js === "object") {
        for (const k of Object.keys(js)) if (Array.isArray(js[k])) return js[k];
      }
      return [];
    }

    function toPathString(x) {
      if (x == null) return "";
      if (typeof x === "string") return x;
      if (typeof x === "object") {
        return x.url || x.href || x.path || x.name || x.file || x.filename || "";
      }
      return String(x);
    }

    function buildFileObjects(list) {
      const files = [];
      for (const item of list) {
        const p0 = toPathString(item);
        if (!p0) continue;

        const fn = basename(p0);
        const tUtc = parseUtcFromFilename(fn) || parseUtcFromFilename(p0);
        if (!tUtc) continue;

        const url = (p0.startsWith("http://") || p0.startsWith("https://")) ? p0
                  : (p0.includes("/") ? ("https://services.swpc.noaa.gov/" + p0.replace(/^\/+/,""))
                                     : (NOAA_GLOTEC_BASE_URL + fn));
        files.push({ fn, tUtc, url });
      }
      files.sort((a,b)=>a.tUtc-b.tUtc);
      return files;
    }

    function pickPrevDayTargetsFromLatest(files, intervalMinutes) {
      if (!files.length) return null;

      const latest = files[files.length-1].tUtc;
      const latestDayStart = new Date(Date.UTC(latest.getUTCFullYear(), latest.getUTCMonth(), latest.getUTCDate(), 0,0,0));
      const prevDayStart = new Date(latestDayStart.getTime() - 24*3600*1000);

      const n = Math.round(24*60/intervalMinutes);
      const targets = [];
      for (let k=0;k<n;k++) targets.push(new Date(prevDayStart.getTime() + k*intervalMinutes*60*1000));
      return { prevDayStart, targets, prevKey: toDayKeyUtc(prevDayStart) };
    }

    function nearestFileForTime(files, tTarget, maxDiffMin=70) {
      let best = null, bestDiff = 1e99;
      for (const f of files) {
        const diff = Math.abs(f.tUtc - tTarget);
        if (diff < bestDiff) { bestDiff = diff; best = f; }
      }
      if (!best) return null;
      const maxMs = maxDiffMin * 60 * 1000;
      if (bestDiff > maxMs) return null;
      return best;
    }

    async function fetchAllWithLimit(urls, limit=6) {
      const out = new Array(urls.length);
      let idx = 0;

      async function worker() {
        while (idx < urls.length) {
          const i = idx++;
          out[i] = await fetchText(urls[i]);
        }
      }

      const workers = [];
      for (let k=0;k<Math.min(limit, urls.length); k++) workers.push(worker());
      await Promise.all(workers);
      return out;
    }

    function renderNoaa12Table() {
      const body = document.getElementById("noaa12TableBody");
      const pill = document.getElementById("noaa12KeyPill");
      if (pill) pill.textContent = "day: " + (gNoaaDayKey || "--");

      if (!body) return;
      body.innerHTML = "";
      if (!gNoaaDayTimes || !gNoaaDayFiles) {
        const tr = document.createElement("tr");
        tr.innerHTML = `<td colspan="3" class="small">未取得</td>`;
        body.appendChild(tr);
        return;
      }

      for (let i=0;i<gNoaaDayTimes.length;i++) {
        const t = gNoaaDayTimes[i];
        const fn = gNoaaDayFiles[i] || "";
        const tr = document.createElement("tr");
        tr.innerHTML = `<td class="mono">${String(i+1).padStart(2,"0")}</td>
                        <td class="mono">${t.toISOString().replace(".000Z","Z")}</td>
                        <td class="mono">${fn}</td>`;
        body.appendChild(tr);
      }
    }

    async function fetchNoaaGloTecPrevDay12_2hour(saveAfter=false) {
      try {
        const intervalMin = 120;  // 2時間
        const maxDiffMin  = 90;   // 余裕

        setStatus("noaaTecStatus", "NOAA GloTEC 一覧(JSON)取得中…");
        const idx = await fetchJson(NOAA_GLOTEC_INDEX_URL);

        const listRaw = normalizeGloTecIndexJson(idx).map(toPathString).filter(Boolean);
        const list = listRaw.filter(x => {
          const s = String(x).toLowerCase();
          return s.endsWith(".geojson") || s.includes(".geojson");
        });

        if (!list.length) {
          const hint = Array.isArray(listRaw) ? listRaw.slice(0, 8).join(" / ") : "";
          throw new Error("一覧JSONから geojson が見つかりません（仕様変更/障害の可能性）。先頭例: " + hint);
        }

        const files = buildFileObjects(list);
        if (!files.length) throw new Error("ファイル名からUTCが抽出できません（命名規則が想定外）");

        const meta = pickPrevDayTargetsFromLatest(files, intervalMin);
        if (!meta) throw new Error("前日ターゲット生成に失敗");

        const { targets, prevKey } = meta;

        const picks = [];
        for (const t of targets) picks.push(nearestFileForTime(files, t, maxDiffMin));

        const prevDayFiles = files.filter(f => toDayKeyUtc(f.tUtc) === prevKey);
        for (let i=0;i<picks.length;i++) {
          if (picks[i]) continue;
          const alt = nearestFileForTime(prevDayFiles, targets[i], 240);
          picks[i] = alt || null;
        }

        if (picks.some(x=>!x)) {
          const miss = picks.filter(x=>!x).length;
          throw new Error(`前日(UTC)の${targets.length}枠のうち ${miss} 枠が取得不能（一覧欠損/メンテ等）`);
        }

        if (gNoaaDayKey === prevKey && gNoaaDayFrames && gNoaaDayFrames.length === targets.length) {
          setStatus("noaaTecStatus", `既にメモリに保持済み: NOAA 前日(UTC)=${prevKey}（${targets.length}枚）`);
          renderNoaa12Table();
          fillForecastStartCandidates();
          return;
        }

        setStatus("noaaTecStatus", `前日(UTC)=${prevKey} を${targets.length}枚取得中…（2時間おき）`);

        const urls = picks.map(x => x.url);
        const texts = await fetchAllWithLimit(urls, 6);

        const frames = [];
        for (let i=0;i<targets.length;i++) {
          const vt = targets[i];
          const f = parseNoaaGloTecGeoJson(texts[i], vt, 2.0, 5.0);
          frames.push(f);
        }

        gNoaaDayFrames = frames;
        gNoaaDayTimes  = targets.slice();
        gNoaaDayFiles  = picks.map(x=>x.fn);
        gNoaaDayKey    = prevKey;

        for (let k=0;k<9;k++) {
          const ta = document.getElementById(NOAA_INPUT_IDS[k]);
          if (ta) ta.value = texts[k] || "";
          gNoaaInputTimes[k] = targets[k] || null;
          gNoaaInputFiles[k] = picks[k]?.fn || null;
        }

        if (saveAfter) saveBomInputs();

        setStatus("noaaTecStatus", `NOAA 前日(UTC)=${prevKey} を${targets.length}枚メモリ保持OK（予報はこの${targets.length}枚を使用）`);
        renderNoaa12Table();
        fillForecastStartCandidates();
      } catch (e) {
        console.error(e);
        setStatus("noaaTecStatus", "失敗: " + e.message);
      }
    }

    /* ============================
     *  BoM 9枚 API取得
     * ============================ */
    async function fetchBomTec9FromApi(saveAfter=false) {
      try {
        setStatus("bomApiStatus", "BoM TEC を取得中…（9枚）");
        const texts = await Promise.all(
          BOM_TEC_FILES_9.map(fn => fetchText(BOM_TEC_BASE_URL + fn))
        );
        const ids = NOAA_INPUT_IDS;
        for (let i=0;i<ids.length;i++) {
          const ta = document.getElementById(ids[i]);
          if (ta) ta.value = texts[i] || "";
        }
        const times = texts.map(t => {
          const d = parseBomValidTime(t);
          return d ? d.toISOString().replace(".000Z","Z") : "--";
        });
        setStatus("bomApiStatus", "BoM API取得OK: " + times.join(" / "));
        if (saveAfter) saveBomInputs();
        fillForecastStartCandidates();
      } catch (e) {
        console.error(e);
        setStatus("bomApiStatus", "BoM API取得失敗: " + e.message + "（CORS制限なら手動コピペ運用）");
      }
    }

    async function fetchNoaa3DayGeomagToTextarea() {
      try {
        setStatus("noaa3dayStatus", "取得中…");
        const txt = await fetchText(NOAA_3DAY_GEOMAG_TEXT_URL);
        const ta = document.getElementById("noaaKpText");
        if (ta) ta.value = txt;
        setStatus("noaa3dayStatus", "OK");
      } catch (e) {
        console.error(e);
        setStatus("noaa3dayStatus", "失敗: " + e.message);
      }
    }

    async function fetchNoaaPlanetaryKIndex1DayToBase() {
      try {
        setStatus("kindexStatus", "取得中…");
        const data = await fetchJson(NOAA_PLANETARY_K_INDEX_URL);
        const ta = document.getElementById("baseKpJson");
        if (ta) ta.value = JSON.stringify(data);
        setStatus("kindexStatus", "OK（Base用Kpへ反映）");
      } catch (e) {
        console.error(e);
        setStatus("kindexStatus", "失敗: " + e.message);
      }
    }

    function parseFlareClass(cls) {
      const s = String(cls || "").trim().toUpperCase();
      if (!s) return null;
      const head = s[0];
      if (head !== "M" && head !== "X") return null;
      const mag = parseFloat(s.slice(1));
      return { head, mag: isFinite(mag) ? mag : 1.0 };
    }

    async function fetchNoaaXrayFlareLatestToBase() {
      try {
        setStatus("xrayflareStatus", "取得中…");
        const arr = await fetchJson(NOAA_XRAY_FLARES_LATEST_URL);
        if (!Array.isArray(arr) || arr.length === 0) {
          setStatus("xrayflareStatus", "データなし");
          return;
        }

        const f = arr[0];
        const cls = f.max_class || f.current_class || "";
        const p = parseFlareClass(cls);

        if (!p) {
          document.getElementById("baseFlareJson").value = JSON.stringify([]);
          setStatus("xrayflareStatus", `C以下（${cls || "N/A"}）→ Baseフレア=0`);
          return;
        }

        let strength01 = 0;
        if (p.head === "M") strength01 = Math.min(0.9, 0.2 + 0.08 * p.mag);
        else strength01 = 1.0;

        const Px = (p.head === "X") ? (strength01 * 100) : 0;
        const Pm = (p.head === "M") ? (strength01 * 100) : 0;

        const t = toUtcDateFromSwpcTimeTag(f.time_tag || f.max_time || f.peak_time || "");

        const obj = [{
          time: t ? t.toISOString() : new Date().toISOString(),
          Px: +Px.toFixed(2),
          Pm: +Pm.toFixed(2)
        }];

        document.getElementById("baseFlareJson").value = JSON.stringify(obj, null, 2);
        setStatus("xrayflareStatus", `OK: ${cls} → Px=${obj[0].Px}, Pm=${obj[0].Pm}`);
      } catch (e) {
        console.error(e);
        setStatus("xrayflareStatus", "失敗: " + e.message);
      }
    }

    /* ============================
     *  グローバル状態
     * ============================ */
    const FORECAST_HOURS = 24 * 4; // 4日
    const DT_MINUTES     = 30;
    const N_STEPS = Math.round(FORECAST_HOURS * 60 / DT_MINUTES); // 192

    let gGrid = null;              // {latArr, lonArr, nLat, nLon}
    let gForecastFrames = [];      // frame grids (nLat x nLon)
    let gForecastTimes  = [];      // Date[N_STEPS+1]
    let gForecastStart  = null;    // Date

    let currentStepIndex = 0;

    let gTecColorScale = [
      { limit: 10,  color: "#00ff00" },
      { limit: 30,  color: "#ffff00" },
      { limit: 60,  color: "#ff9900" },
      { limit: 120, color: "#ff0000" }
    ];

    let gGpsColorScale = [
      { limit: 5,  color: "#00ff00" },
      { limit: 10, color: "#ffff00" },
      { limit: 20, color: "#ff9900" },
      { limit: 40, color: "#ff0000" }
    ];

    let gKpSeries        = []; // 予報Kp
    let gBaseKpSeries    = []; // BaseKp
    let gBaseFlareSeries = []; // Base flare

    let map = null;
    let tecCanvas = null;
    let tecCtx = null;
    let tecLegendControl = null;
    let tecAlpha = 0.8;
    let mapMode = "tec";

    const STORAGE_KEY_CONFIG   = "swifttec_config_v4_additive_base";
    const STORAGE_KEY_BOM      = "swifttec_inputs_v9_noaa_prevday12_2h";
    const STORAGE_KEY_TCOL     = "swifttec_teccol_v3";
    const STORAGE_KEY_GCOL     = "swifttec_gpscol_v1";

    function logInfo(msg) {
      const div = document.getElementById("runInfo");
      if (div) div.textContent = msg;
      console.log(msg);
    }
    function clamp(v, a, b) { return v < a ? a : (v > b ? b : v); }

    /* ============================
     *  ★描画をrAFでまとめる（スライダー軽量化）
     * ============================ */
    let _drawQueued = false;
    function requestDraw() {
      if (_drawQueued) return;
      _drawQueued = true;
      requestAnimationFrame(() => {
        _drawQueued = false;
        drawTecOverlay(); // 実描画はここに集約
      });
    }

    /* ===== VALID DATE/TIME: 11/11/2025 00:00:00UTC ===== */
    function parseBomValidTime(text) {
      const lines = String(text || "").split(/\r?\n/);
      for (const line of lines) {
        const m = line.match(/VALID DATE\/TIME:\s*(\d{1,2})\/(\d{1,2})\/(\d{4})\s+(\d{1,2}):(\d{2}):(\d{2})/i);
        if (m) {
          const d  = parseInt(m[1],10);
          const mo = parseInt(m[2],10);
          const y  = parseInt(m[3],10);
          const hh = parseInt(m[4],10);
          const mm = parseInt(m[5],10);
          const ss = parseInt(m[6],10);
          return new Date(Date.UTC(y, mo-1, d, hh, mm, ss));
        }
      }
      return null;
    }

    /* ====== BoM TEC テキスト → 格子データ ====== */
    function parseBoM(text) {
      const lines = String(text || "").split(/\r?\n/).filter(l => l.trim().length > 0);
      if (!lines.length) throw new Error("空のテキストです。");

      let latMin, latMax, latStep, nLat;
      let lonMin, lonMax, lonStep, nLon;

      for (const line of lines) {
        if (/LATITUDE GRID/i.test(line)) {
          const m = line.match(/LATITUDE GRID.*:\s*([-\d.]+)\s+([-\d.]+)\s+([-\d.]+)\s+(\d+)/i);
          if (m) {
            latMin  = parseFloat(m[1]);
            latMax  = parseFloat(m[2]);
            latStep = parseFloat(m[3]);
            nLat    = parseInt(m[4],10);
          }
        } else if (/LONGITUDE GRID/i.test(line)) {
          const m = line.match(/LONGITUDE GRID.*:\s*([-\d.]+)\s+([-\d.]+)\s+([-\d.]+)\s+(\d+)/i);
          if (m) {
            lonMin  = parseFloat(m[1]);
            lonMax  = parseFloat(m[2]);
            lonStep = parseFloat(m[3]);
            nLon    = parseInt(m[4],10);
          }
        }
      }
      if (latMin === undefined || lonMin === undefined) {
        throw new Error("LATITUDE/LONGITUDE GRID 情報が見つかりません。");
      }

      const valLines = lines.filter(l => !l.trim().startsWith("#") && !/GRID/i.test(l));
      const values = [];
      for (const ln of valLines) {
        const parts = ln.split(/[, ]+/).map(x => x.trim()).filter(x => x.length>0);
        for (const p of parts) {
          const v = parseFloat(p);
          if (!isNaN(v)) values.push(v);
        }
      }
      if (values.length !== nLat*nLon) {
        throw new Error(`データ数が不一致です: ${values.length} vs ${nLat*nLon}`);
      }

      const latArr = [];
      for (let i=0;i<nLat;i++) latArr.push(latMin + latStep*i);

      const lonArr = [];
      for (let j=0;j<nLon;j++) lonArr.push(lonMin + lonStep*j);

      const grid = new Array(nLat);
      let idx = 0;
      for (let i=0;i<nLat;i++) {
        grid[i] = new Array(nLon);
        for (let j=0;j<nLon;j++) grid[i][j] = values[idx++];
      }

      const validTime = parseBomValidTime(text);
      return { latArr, lonArr, nLat, nLon, grid, validTime };
    }

    /* ============================
     *  NOAA GloTEC GeoJSON → 2°×5° Grid
     * ============================ */
    function parseNoaaGloTecGeoJson(text, validTimeFromFilename=null, targetLatStep=2.0, targetLonStep=5.0) {
      let obj;
      try { obj = JSON.parse(text); } catch { throw new Error("NOAA GeoJSONがJSONとして読めません"); }
      if (!obj || !Array.isArray(obj.features)) throw new Error("NOAA GeoJSON featuresが見つかりません");

      const candidateKeys = ["tec","vtec","VTEC","TEC","value","Value","grid_value","gridValue","tecu","TECU"];
      let valueKey = null;

      for (const f of obj.features) {
        const p = f && f.properties;
        if (!p) continue;
        for (const k of candidateKeys) {
          if (p[k] !== undefined && isFinite(parseFloat(p[k]))) { valueKey = k; break; }
        }
        if (valueKey) break;
      }
      if (!valueKey) {
        for (const f of obj.features) {
          const p = f && f.properties;
          if (!p) continue;
          for (const k of Object.keys(p)) {
            const v = parseFloat(p[k]);
            if (isFinite(v)) { valueKey = k; break; }
          }
          if (valueKey) break;
        }
      }
      if (!valueKey) throw new Error("TEC値プロパティが特定できません（propertiesに数値が無い）");

      const pts = [];
      for (const f of obj.features) {
        if (!f || !f.geometry) continue;
        let v = parseFloat(f.properties?.[valueKey]);
        if (!isFinite(v)) continue;

        v = Math.floor(v);
        if (v < 0) v = 0;

        const g = f.geometry;
        if (g.type === "Point" && Array.isArray(g.coordinates) && g.coordinates.length >= 2) {
          let lon = +g.coordinates[0];
          let lat = +g.coordinates[1];
          if (!isFinite(lat) || !isFinite(lon)) continue;
          lon = ((lon + 180) % 360) - 180;
          pts.push({ lat, lon, tec: v });
          continue;
        }

        let coords = null;
        if (g.type === "Polygon") coords = g.coordinates?.[0];
        else if (g.type === "MultiPolygon") coords = g.coordinates?.[0]?.[0];

        if (!Array.isArray(coords) || coords.length < 3) continue;

        let sumLon=0, sumLat=0, n=0;
        for (const c of coords) {
          if (!Array.isArray(c) || c.length < 2) continue;
          const lon = +c[0], lat = +c[1];
          if (!isFinite(lat) || !isFinite(lon)) continue;
          sumLon += lon; sumLat += lat; n++;
        }
        if (n===0) continue;
        let lonC = sumLon/n;
        lonC = ((lonC + 180) % 360) - 180;
        pts.push({ lat: sumLat/n, lon: lonC, tec: v });
      }

      if (!pts.length) throw new Error("GeoJSONから格子点が作れませんでした（Point/Polygonが想定外？）");

      const latArr = [];
      for (let lat=-90; lat<=90+1e-9; lat+=targetLatStep) latArr.push(+lat.toFixed(6));

      const lonArr = [];
      for (let lon=-180; lon<=180-1e-9; lon+=targetLonStep) lonArr.push(+lon.toFixed(6)); // -180..175

      const nLat = latArr.length, nLon = lonArr.length;
      const grid = Array.from({length:nLat}, ()=>Array.from({length:nLon}, ()=>NaN));

      // ※ここは重いけど、NOAA入力は12枚だけ想定なので許容（必要ならKD-tree化）
      for (let i=0;i<nLat;i++) {
        const lat0 = latArr[i];
        for (let j=0;j<nLon;j++) {
          const lon0 = lonArr[j];

          let best=null, bestD=1e99;
          for (const p of pts) {
            let dLon = Math.abs(p.lon - lon0);
            dLon = Math.min(dLon, 360 - dLon);
            const d = Math.abs(p.lat - lat0) + dLon;
            if (d < bestD) { bestD = d; best = p; }
          }
          grid[i][j] = best ? best.tec : NaN;
        }
      }

      const validTime = (validTimeFromFilename instanceof Date && !isNaN(validTimeFromFilename.getTime()))
        ? validTimeFromFilename
        : null;

      return { latArr, lonArr, nLat, nLon, grid, validTime };
    }

    /* ============ 入力保存 ============ */
    function saveBomInputs() {
      const data = {
        tecSource: document.getElementById("tecSourceSelect")?.value || "bom",
        bomInput1: document.getElementById("bomInput1").value,
        bomInput2: document.getElementById("bomInput2").value,
        bomInput3: document.getElementById("bomInput3").value,
        bomInput4: document.getElementById("bomInput4").value,
        bomInput5: document.getElementById("bomInput5").value,
        bomInput6: document.getElementById("bomInput6").value,
        bomInput7: document.getElementById("bomInput7").value,
        bomInput8: document.getElementById("bomInput8").value,
        bomInput9: document.getElementById("bomInput9").value,
        noaaTimes: (gNoaaInputTimes || []).map(d => (d instanceof Date && !isNaN(d.getTime())) ? d.toISOString() : null),
        noaaFiles: (gNoaaInputFiles || []).map(x => x || null),
        noaaPrevDayKey: gNoaaDayKey || null
      };
      localStorage.setItem(STORAGE_KEY_BOM, JSON.stringify(data));
      logInfo("入力（BoM/NOAA）を保存しました。（次回起動時に自動復元）");
    }

    function loadBomInputsFromStorage() {
      const s = localStorage.getItem(STORAGE_KEY_BOM);
      if (!s) return;
      try {
        const data = JSON.parse(s);
        if (data.tecSource) document.getElementById("tecSourceSelect").value = data.tecSource;

        if (data.bomInput1 !== undefined) document.getElementById("bomInput1").value = data.bomInput1;
        if (data.bomInput2 !== undefined) document.getElementById("bomInput2").value = data.bomInput2;
        if (data.bomInput3 !== undefined) document.getElementById("bomInput3").value = data.bomInput3;
        if (data.bomInput4 !== undefined) document.getElementById("bomInput4").value = data.bomInput4;
        if (data.bomInput5 !== undefined) document.getElementById("bomInput5").value = data.bomInput5;
        if (data.bomInput6 !== undefined) document.getElementById("bomInput6").value = data.bomInput6;
        if (data.bomInput7 !== undefined) document.getElementById("bomInput7").value = data.bomInput7;
        if (data.bomInput8 !== undefined) document.getElementById("bomInput8").value = data.bomInput8;
        if (data.bomInput9 !== undefined) document.getElementById("bomInput9").value = data.bomInput9;

        if (Array.isArray(data.noaaTimes)) {
          gNoaaInputTimes = data.noaaTimes.map(x => {
            if (!x) return null;
            const d = new Date(x);
            return isNaN(d.getTime()) ? null : d;
          });
          while (gNoaaInputTimes.length < 9) gNoaaInputTimes.push(null);
          gNoaaInputTimes = gNoaaInputTimes.slice(0,9);
        }
        if (Array.isArray(data.noaaFiles)) {
          gNoaaInputFiles = data.noaaFiles.map(x => x || null);
          while (gNoaaInputFiles.length < 9) gNoaaInputFiles.push(null);
          gNoaaInputFiles = gNoaaInputFiles.slice(0,9);
        }
        if (data.noaaPrevDayKey) gNoaaDayKey = data.noaaPrevDayKey;
      } catch(e) {
        console.warn("入力の復元に失敗:", e);
      }
    }

    function clearBomInputsStorage() {
      localStorage.removeItem(STORAGE_KEY_BOM);
      logInfo("保存されていた 入力（BoM/NOAA）を削除しました。（テキスト内容はそのまま）");
    }

    /* ============ Config（係数） ============ */
    function getConfigFromUI() {
      return {
        kBase:     parseFloat(document.getElementById("cfg_kBase").value)     || 1.0,
        kStorm:    parseFloat(document.getElementById("cfg_kStorm").value)    || 1.0,
        betaFlare: parseFloat(document.getElementById("cfg_betaFlare").value) || 0.7,
        kX:        parseFloat(document.getElementById("cfg_kX").value)        || 1.0,
        kM:        parseFloat(document.getElementById("cfg_kM").value)        || 0.5,
        kL1:       parseFloat(document.getElementById("cfg_kL1").value)       || 0.16
      };
    }

    function applyConfigToUI(cfg) {
      document.getElementById("cfg_kBase").value     = cfg.kBase     ?? 1.0;
      document.getElementById("cfg_kStorm").value    = cfg.kStorm    ?? 1.0;
      document.getElementById("cfg_betaFlare").value = cfg.betaFlare ?? 0.7;
      document.getElementById("cfg_kX").value        = cfg.kX        ?? 1.0;
      document.getElementById("cfg_kM").value        = cfg.kM        ?? 0.5;
      document.getElementById("cfg_kL1").value       = cfg.kL1       ?? 0.16;
      updateFormulaText();
    }

    function saveConfig() {
      const cfg = getConfigFromUI();
      localStorage.setItem(STORAGE_KEY_CONFIG, JSON.stringify(cfg));
      logInfo("係数設定を保存しました。");
      updateFormulaText();
      requestDraw();
    }

    function loadConfig(apply) {
      const s = localStorage.getItem(STORAGE_KEY_CONFIG);
      if (!s) {
        if (apply) {
          updateFormulaText();
          logInfo("保存された係数がありません。初期値を使用。");
        }
        return null;
      }
      try {
        const cfg = JSON.parse(s);
        if (apply) applyConfigToUI(cfg);
        return cfg;
      } catch(e) {
        console.warn("Configの復元に失敗:", e);
        return null;
      }
    }

    /* ============ TEC / GPS カラーマップ設定 ============ */
    function applyTecColorScale() {
      const limits = [
        parseFloat(document.getElementById("tLimit1").value) || 10,
        parseFloat(document.getElementById("tLimit2").value) || 30,
        parseFloat(document.getElementById("tLimit3").value) || 60,
        parseFloat(document.getElementById("tLimit4").value) || 120
      ];
      const cols = [
        document.getElementById("tColor1").value || "#00ff00",
        document.getElementById("tColor2").value || "#ffff00",
        document.getElementById("tColor3").value || "#ff9900",
        document.getElementById("tColor4").value || "#ff0000"
      ];
      gTecColorScale = [
        { limit: limits[0], color: cols[0] },
        { limit: limits[1], color: cols[1] },
        { limit: limits[2], color: cols[2] },
        { limit: limits[3], color: cols[3] }
      ];
      localStorage.setItem(STORAGE_KEY_TCOL, JSON.stringify(gTecColorScale));
      logInfo("TECカラースケールを保存しました。");
      updateTecLegend();
      requestDraw();
    }

    function resetTecColorScale() {
      gTecColorScale = [
        { limit: 10,  color: "#00ff00" },
        { limit: 30,  color: "#ffff00" },
        { limit: 60,  color: "#ff9900" },
        { limit: 120, color: "#ff0000" }
      ];
      document.getElementById("tLimit1").value = 10;
      document.getElementById("tLimit2").value = 30;
      document.getElementById("tLimit3").value = 60;
      document.getElementById("tLimit4").value = 120;
      document.getElementById("tColor1").value = "#00ff00";
      document.getElementById("tColor2").value = "#ffff00";
      document.getElementById("tColor3").value = "#ff9900";
      document.getElementById("tColor4").value = "#ff0000";
      localStorage.setItem(STORAGE_KEY_TCOL, JSON.stringify(gTecColorScale));
      updateTecLegend();
      requestDraw();
    }

    function loadTecColorScaleFromStorage() {
      const s = localStorage.getItem(STORAGE_KEY_TCOL);
      if (!s) return;
      try {
        const arr = JSON.parse(s);
        if (!Array.isArray(arr) || arr.length !== 4) return;
        gTecColorScale = arr;
        document.getElementById("tLimit1").value = arr[0].limit;
        document.getElementById("tLimit2").value = arr[1].limit;
        document.getElementById("tLimit3").value = arr[2].limit;
        document.getElementById("tLimit4").value = arr[3].limit;
        document.getElementById("tColor1").value = arr[0].color;
        document.getElementById("tColor2").value = arr[1].color;
        document.getElementById("tColor3").value = arr[2].color;
        document.getElementById("tColor4").value = arr[3].color;
      } catch(e) {}
    }

    function applyGpsColorScale() {
      const limits = [
        parseFloat(document.getElementById("gLimit1").value) || 5,
        parseFloat(document.getElementById("gLimit2").value) || 10,
        parseFloat(document.getElementById("gLimit3").value) || 20,
        parseFloat(document.getElementById("gLimit4").value) || 40
      ];
      const cols = [
        document.getElementById("gColor1").value || "#00ff00",
        document.getElementById("gColor2").value || "#ffff00",
        document.getElementById("gColor3").value || "#ff9900",
        document.getElementById("gColor4").value || "#ff0000"
      ];
      gGpsColorScale = [
        { limit: limits[0], color: cols[0] },
        { limit: limits[1], color: cols[1] },
        { limit: limits[2], color: cols[2] },
        { limit: limits[3], color: cols[3] }
      ];
      localStorage.setItem(STORAGE_KEY_GCOL, JSON.stringify(gGpsColorScale));
      logInfo("GPS色スケールを保存しました。");
      updateTecLegend();
      requestDraw();
    }

    function resetGpsColorScale() {
      gGpsColorScale = [
        { limit: 5,  color: "#00ff00" },
        { limit: 10, color: "#ffff00" },
        { limit: 20, color: "#ff9900" },
        { limit: 40, color: "#ff0000" }
      ];
      document.getElementById("gLimit1").value = 5;
      document.getElementById("gLimit2").value = 10;
      document.getElementById("gLimit3").value = 20;
      document.getElementById("gLimit4").value = 40;
      document.getElementById("gColor1").value = "#00ff00";
      document.getElementById("gColor2").value = "#ffff00";
      document.getElementById("gColor3").value = "#ff9900";
      document.getElementById("gColor4").value = "#ff0000";
      localStorage.setItem(STORAGE_KEY_GCOL, JSON.stringify(gGpsColorScale));
      updateTecLegend();
      requestDraw();
    }

    function loadGpsColorScaleFromStorage() {
      const s = localStorage.getItem(STORAGE_KEY_GCOL);
      if (!s) return;
      try {
        const arr = JSON.parse(s);
        if (!Array.isArray(arr) || arr.length !== 4) return;
        gGpsColorScale = arr;
        document.getElementById("gLimit1").value = arr[0].limit;
        document.getElementById("gLimit2").value = arr[1].limit;
        document.getElementById("gLimit3").value = arr[2].limit;
        document.getElementById("gLimit4").value = arr[3].limit;
        document.getElementById("gColor1").value = arr[0].color;
        document.getElementById("gColor2").value = arr[1].color;
        document.getElementById("gColor3").value = arr[2].color;
        document.getElementById("gColor4").value = arr[3].color;
      } catch(e) {}
    }

    /* ============================
     *  NOAA Kp パーサ（強化版）
     * ============================ */
    function parseKpText(raw) {
      const text = String(raw || "");
      if (/NOAA Kp index breakdown/i.test(text)) return parseKpFrom3DayBreakdown(text);
      if (/NOAA Kp index forecast/i.test(text)) {
        const s2 = parseKpFromGeomagForecastTable(text);
        if (s2.length) return s2;
      }
      return parseKpGenericLine(text);
    }

    function parseKpGenericLine(text) {
      const lines = text.split(/\r?\n/);
      const out = [];
      for (const line of lines) {
        const m = line.match(/(\d{4})[\/\-\s](\d{1,2})[\/\-\s](\d{1,2})[T\s]+(\d{1,2})/);
        if (!m) continue;

        const y  = parseInt(m[1],10);
        const mo = parseInt(m[2],10);
        const d  = parseInt(m[3],10);
        const hh = parseInt(m[4],10);

        const tokens = line.trim().split(/\s+/);
        if (!tokens.length) continue;
        const kpToken = tokens[tokens.length-1];

        let kp = null;
        let m3 = kpToken.match(/^(\d+(\.\d+)?)/);
        if (m3) kp = parseFloat(m3[1]);
        else {
          const m4 = kpToken.match(/^([0-9])([\-+o]?)$/i);
          if (m4) {
            kp = parseInt(m4[1],10);
            const sfx = m4[2];
            if (sfx === "+") kp += 0.33;
            else if (sfx === "-") kp -= 0.33;
          }
        }
        if (kp === null || isNaN(kp)) continue;

        const t = new Date(Date.UTC(y, mo-1, d, hh, 0, 0));
        out.push({ time: t, kp: kp });
      }
      out.sort((a,b) => a.time - b.time);
      return out;
    }

    function parseKpFrom3DayBreakdown(raw) {
      const lines = raw.split(/\r?\n/);
      const out = [];
      const monthMap = { Jan:0, Feb:1, Mar:2, Apr:3, May:4, Jun:5, Jul:6, Aug:7, Sep:8, Oct:9, Nov:10, Dec:11 };

      let idxBreak = -1;
      for (let i=0;i<lines.length;i++) if (/NOAA Kp index breakdown/i.test(lines[i])) { idxBreak = i; break; }
      if (idxBreak < 0) return out;

      let year = null;
      const mYear = lines[idxBreak].match(/(\d{4})\s*$/);
      if (mYear) year = parseInt(mYear[1],10);

      let headerLine = null;
      let headerIndex = -1;
      for (let i=idxBreak+1;i<lines.length;i++) {
        const ln = lines[i].trim();
        if (!ln) continue;
        if (/[A-Za-z]{3}\s+\d{1,2}/.test(ln)) { headerLine = lines[i]; headerIndex = i; break; }
      }
      if (!headerLine || year === null) return out;

      const headerTokens = headerLine.trim().split(/\s+/);
      if (headerTokens.length % 2 !== 0) return out;

      const colDates = [];
      for (let i=0;i<headerTokens.length;i+=2) {
        const mon = headerTokens[i];
        const day = parseInt(headerTokens[i+1],10);
        const mi  = monthMap[mon] !== undefined ? monthMap[mon] : monthMap[String(mon).slice(0,3)];
        if (mi === undefined || isNaN(day)) continue;
        colDates.push(new Date(Date.UTC(year, mi, day, 0, 0, 0)));
      }
      if (!colDates.length) return out;

      const patUT = /^\s*(\d{2})-(\d{2})UT/;
      for (let i=headerIndex+1;i<lines.length;i++) {
        const line = lines[i];
        const m = line.match(patUT);
        if (!m) continue;

        const startHour = parseInt(m[1],10);
        const tokens = line.trim().split(/\s+/);
        if (tokens.length < 1 + colDates.length) continue;

        for (let c=0;c<colDates.length;c++) {
          const vStr = tokens[1+c];
          const kpVal = parseFloat(vStr);
          if (!isNaN(kpVal)) {
            const baseDate = colDates[c];
            const t = new Date(Date.UTC(
              baseDate.getUTCFullYear(),
              baseDate.getUTCMonth(),
              baseDate.getUTCDate(),
              startHour, 0, 0
            ));
            out.push({ time: t, kp: kpVal });
          }
        }
      }
      out.sort((a,b) => a.time - b.time);
      return out;
    }

    function parseKpFromGeomagForecastTable(raw) {
      const lines = raw.split(/\r?\n/);
      const out = [];
      const monthMap = { Jan:0, Feb:1, Mar:2, Apr:3, May:4, Jun:5, Jul:6, Aug:7, Sep:8, Oct:9, Nov:10, Dec:11 };

      let year = null;
      for (const ln of lines) {
        const m = ln.match(/:Issued:\s*(\d{4})\s+([A-Za-z]{3})\s+(\d{1,2})/);
        if (m) { year = parseInt(m[1],10); break; }
      }
      if (!year) year = new Date().getUTCFullYear();

      let idx = -1;
      for (let i=0;i<lines.length;i++) if (/NOAA Kp index forecast/i.test(lines[i])) { idx = i; break; }
      if (idx < 0) return out;

      let headerLine = null;
      for (let i=idx; i<Math.min(lines.length, idx+12); i++) {
        const ln = lines[i].trim();
        if (!ln) continue;
        if (/(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+\d{1,2}/.test(ln) && !/UT/.test(ln)) { headerLine = ln; break; }
      }
      if (!headerLine) return out;

      const toks = headerLine.trim().split(/\s+/);
      if (toks.length < 4 || toks.length % 2 !== 0) return out;

      const days = [];
      for (let k=0;k<toks.length;k+=2) {
        const mon = toks[k];
        const day = parseInt(toks[k+1],10);
        const mi  = monthMap[mon] ?? monthMap[String(mon).slice(0,3)];
        if (mi === undefined || isNaN(day)) continue;
        days.push(new Date(Date.UTC(year, mi, day, 0, 0, 0)));
      }
      if (!days.length) return out;

      const rowRe = /^\s*(\d{2})-(\d{2})UT\s+(.+)$/;
      for (const lnRaw of lines) {
        const m = lnRaw.match(rowRe);
        if (!m) continue;
        const startHour = parseInt(m[1],10);
        const rest = m[3].trim().split(/\s+/);
        if (rest.length < days.length) continue;

        for (let c=0;c<days.length;c++) {
          const kpVal = parseFloat(rest[c]);
          if (isNaN(kpVal)) continue;
          const d0 = days[c];
          const t = new Date(Date.UTC(d0.getUTCFullYear(), d0.getUTCMonth(), d0.getUTCDate(), startHour, 0, 0));
          out.push({ time: t, kp: kpVal });
        }
      }
      out.sort((a,b)=>a.time-b.time);
      return out;
    }

    function sampleSeriesAtUtc(series, tUtc, stepLike=false) {
      if (!series || series.length === 0) return null;
      if (tUtc <= series[0].time) return series[0].kp;
      const last = series[series.length-1];
      if (tUtc >= last.time) return last.kp;

      for (let i=1;i<series.length;i++) {
        if (tUtc < series[i].time) {
          if (stepLike) return series[i-1].kp;
          const a = series[i-1], b = series[i];
          const vA = a.kp, vB = b.kp;
          const tA = a.time.getTime(), tB = b.time.getTime();
          const f  = (tUtc.getTime() - tA) / (tB - tA);
          return vA * (1-f) + vB * f;
        }
      }
      return last.kp;
    }

    function getKpBaseAtUtc(tUtc, kpForecast) {
      if (!gBaseKpSeries || gBaseKpSeries.length === 0) return kpForecast;
      const t0 = gBaseKpSeries[0].time.getTime();
      const t1 = gBaseKpSeries[gBaseKpSeries.length - 1].time.getTime();
      const tt = tUtc.getTime();
      if (tt < t0 || tt > t1) return kpForecast;
      const tmp = sampleSeriesAtUtc(gBaseKpSeries, tUtc, true);
      return (tmp == null) ? kpForecast : tmp;
    }

    /* ===== Base 用 Kp JSON パーサ ===== */
    function toUtcDateFromSwpcTimeTag(tStr) {
      const s = String(tStr || "").trim();
      if (!s) return null;

      let iso = s.includes("T") ? s : s.replace(" ", "T");
      if (!/[zZ]$/.test(iso)) iso += "Z";
      let d = new Date(iso);
      if (!isNaN(d.getTime())) return d;

      const m = s.match(/(\d{4})-(\d{2})-(\d{2})\s+(\d{2}):(\d{2})(?::(\d{2}))?/);
      if (m) {
        const y = parseInt(m[1],10), mo=parseInt(m[2],10), da=parseInt(m[3],10);
        const hh=parseInt(m[4],10), mm=parseInt(m[5],10), ss=parseInt(m[6]||"0",10);
        return new Date(Date.UTC(y, mo-1, da, hh, mm, ss));
      }
      return null;
    }

    function parseBaseKpJson(text) {
      const raw = (text || "").trim();
      if (!raw) return [];
      let data;
      try { data = JSON.parse(raw); } catch { return []; }
      const series = [];

      if (Array.isArray(data) && data.length && Array.isArray(data[0])) {
        const header = data[0];
        const timeIdx = header.indexOf("time_tag");
        const kpIdx   = header.indexOf("Kp");
        if (timeIdx >= 0 && kpIdx >= 0) {
          for (let i=1;i<data.length;i++) {
            const row = data[i];
            if (!row || row.length <= Math.max(timeIdx,kpIdx)) continue;
            const d = toUtcDateFromSwpcTimeTag(String(row[timeIdx]));
            const kp = parseFloat(String(row[kpIdx]));
            if (d && !isNaN(kp)) series.push({ time: d, kp });
          }
        }
      } else if (Array.isArray(data)) {
        for (const obj of data) {
          if (!obj) continue;
          const tStr = obj.time || obj.time_tag;
          const kpVal = obj.kp ?? obj.Kp;
          if (!tStr || kpVal === undefined) continue;
          const d = toUtcDateFromSwpcTimeTag(tStr);
          const kp = parseFloat(kpVal);
          if (d && !isNaN(kp)) series.push({ time: d, kp });
        }
      }

      series.sort((a,b)=>a.time-b.time);
      return series;
    }

    /* ===== Base 用 フレア JSON パーサ ===== */
    function parseBaseFlareJson(text) {
      const raw = (text || "").trim();
      if (!raw) return [];
      let data;
      try { data = JSON.parse(raw); } catch { return []; }
      const series = [];
      if (!Array.isArray(data)) return [];
      for (const obj of data) {
        if (!obj) continue;
        const tStr = obj.time;
        const Px = parseFloat(obj.Px);
        const Pm = parseFloat(obj.Pm);
        if (!tStr || isNaN(Px) || isNaN(Pm)) continue;
        const d = new Date(String(tStr).endsWith("Z") ? tStr : (String(tStr)+"Z"));
        if (isNaN(d.getTime())) continue;
        series.push({ time:d, Px, Pm });
      }
      series.sort((a,b)=>a.time-b.time);
      return series;
    }

    function sampleFlareSeriesAtUtc(series, tUtc) {
      if (!series || !series.length) return { Px:0, Pm:0 };
      const ACTIVE_WINDOW_MIN = 120;
      const activeMs = ACTIVE_WINDOW_MIN * 60 * 1000;

      let best = series[0];
      let bestDiff = Math.abs(tUtc - best.time);
      for (let i=1;i<series.length;i++) {
        const diff = Math.abs(tUtc - series[i].time);
        if (diff < bestDiff) { best = series[i]; bestDiff = diff; }
      }
      if (bestDiff > activeMs) return { Px:0, Pm:0 };
      return { Px: best.Px, Pm: best.Pm };
    }

    /* ===== Deep Flare Net 入力 → ΔFlare ===== */
    function getDeepFlareProbs() {
      let sumX = 0, sumM = 0, count = 0;
      for (let i=1;i<=9;i++) {
        const use = document.getElementById("fu"+i).checked;
        if (!use) continue;
        const px = parseFloat(document.getElementById("fx"+i).value) || 0;
        const pm = parseFloat(document.getElementById("fm"+i).value) || 0;
        sumX += px; sumM += pm; count++;
      }
      if (count === 0) return { Px: 0, Pm: 0 };
      return { Px: sumX/count, Pm: sumM/count };
    }

    function calcDayWeight(latDeg, lonDeg, tUtc) {
      if (!(tUtc instanceof Date) || isNaN(tUtc.getTime())) return 0;
      const rad = Math.PI / 180;
      const phi = latDeg * rad;

      const y = tUtc.getUTCFullYear();
      const startOfYear = Date.UTC(y, 0, 1, 0, 0, 0);
      const N = Math.floor((tUtc.getTime() - startOfYear) / (24*3600*1000)) + 1;

      const gamma = 2 * Math.PI * (N - 1) / 365;
      const delta = 0.006918
                  - 0.399912 * Math.cos(gamma)
                  + 0.070257 * Math.sin(gamma)
                  - 0.006758 * Math.cos(2*gamma)
                  + 0.000907 * Math.sin(2*gamma)
                  - 0.002697 * Math.cos(3*gamma)
                  + 0.00148  * Math.sin(3*gamma);

      const ltSolar = (tUtc.getUTCHours() + tUtc.getUTCMinutes()/60 + lonDeg / 15 + 24) % 24;
      const H = (ltSolar - 12) * 15 * rad;

      const cosChi = Math.sin(phi)*Math.sin(delta) + Math.cos(phi)*Math.cos(delta)*Math.cos(H);
      if (cosChi <= 0) return 0;
      const w = (cosChi - 0.2) / (1 - 0.2);
      return clamp(w, 0, 1);
    }

    function calcFlareDeltaFromProbs(cfg, latDeg, lonDeg, tUtc, Px, Pm) {
      if (Px <= 0 && Pm <= 0) return 0.0;
      const level = cfg.kX*(Px/100) + cfg.kM*(Pm/100);
      if (level <= 0) return 0.0;

      const dayWeight = calcDayWeight(latDeg, lonDeg, tUtc);
      const raw = 15.0 * cfg.betaFlare * level * dayWeight;
      return clamp(raw, 0, 15);
    }

    function calcFlareDeltaForecast(cfg, latDeg, lonDeg, tUtc) {
      const probs = getDeepFlareProbs();
      return calcFlareDeltaFromProbs(cfg, latDeg, lonDeg, tUtc, probs.Px, probs.Pm);
    }

    /* ============================
     *  Sstorm（簡易Mukhtarov風）
     * ============================ */
    const SstormPos_SIGMA_LAT = 15.0;
    const SstormPos_SIGMA_M   = 2.0;

    const SstormPos_KC  = 6.5;
    const SstormPos_W   = 1.2;
    const SstormPos_A0  = 0.01;

    const SstormPos_BASIS = [
      { latAbs:40.0, month:7,  a:[-0.0742756961, 0.08331505314, -0.01888613709, 0.002074999214] },
      { latAbs:40.0, month:11, a:[-0.1106197275, 0.1320345523,  -0.04870525828, 0.005143845605] },
      { latAbs:70.0, month:11, a:[-0.3746087246, 0.3563156192,  -0.09425770425, 0.007924840841] }
    ];

    function sstormPos_evalPoly(a, Kp) {
      const [a0, a1, a2, a3] = a;
      return a0 + a1*Kp + a2*Kp*Kp + a3*Kp*Kp*Kp;
    }
    function sstormPos_monthDiff(m, mi) {
      const d = Math.abs(m - mi);
      return Math.min(d, 12 - d);
    }
    function sstormPos_seasonMonth(latDeg, month) {
      return (latDeg >= 0) ? 11 : 7;
    }
    function gauss(x, mu, sig) {
      const z = (x-mu)/sig;
      return Math.exp(-0.5*z*z);
    }

    function sstormPos_rStorm(Kp, latDeg, month) {
      const latAbs = Math.abs(latDeg);
      const mRef = sstormPos_seasonMonth(latDeg, month);

      let num=0, den=0;
      for (const b of SstormPos_BASIS) {
        const wLat = gauss(latAbs, b.latAbs, SstormPos_SIGMA_LAT);
        const wMon = gauss(sstormPos_monthDiff(month, b.month), 0, SstormPos_SIGMA_M);
        const w = wLat*wMon;
        if (w <= 0) continue;
        const fK = sstormPos_evalPoly(b.a, Kp);
        num += w * fK;
        den += w;
      }
      let f = (den>0) ? (num/den) : 0;

      const wSeason = gauss(sstormPos_monthDiff(month, mRef), 0, 2.5);
      f *= (0.6 + 0.4*wSeason);

      const tail = (Kp <= SstormPos_KC) ? 0 : (SstormPos_A0 * Math.pow(Kp - SstormPos_KC, SstormPos_W));

      const r = 1 + Math.max(0, f) + tail;
      return clamp(r, 1.0, 3.0);
    }

    function calcStormDelta(cfg, baseTec, latDeg, month, kpForecast) {
      const r = sstormPos_rStorm(kpForecast, latDeg, month);
      const d = (r - 1.0) * baseTec * cfg.kStorm;
      return clamp(d, 0, 80);
    }

    /* ============================
     *  入力TEC（BoM/NOAA）をFrame化
     * ============================ */
    function getTecSourceMode() {
      return document.getElementById("tecSourceSelect")?.value || "bom";
    }

    function sampleNoaaDayFrameAtUtc(tUtc) {
      if (!gNoaaDayFrames || !gNoaaDayTimes) return null;
      let bestI = 0;
      let bestD = Math.abs(tUtc - gNoaaDayTimes[0]);
      for (let i=1;i<gNoaaDayTimes.length;i++) {
        const d = Math.abs(tUtc - gNoaaDayTimes[i]);
        if (d < bestD) { bestD = d; bestI = i; }
      }
      return gNoaaDayFrames[bestI] || null;
    }

    function parseBomInputs9() {
      const texts = NOAA_INPUT_IDS.map(id => document.getElementById(id)?.value || "");
      const frames = [];
      for (let i=0;i<texts.length;i++) {
        const t = (texts[i] || "").trim();
        if (!t) continue;
        const p = parseBoM(t);
        frames.push(p);
      }
      if (!frames.length) throw new Error("BoM入力が空です。");
      return frames;
    }

    function fillForecastStartCandidates() {
      const sel = document.getElementById("forecastStartSelect");
      if (!sel) return;
      sel.innerHTML = "";

      const mode = getTecSourceMode();
      let candidates = [];

      if (mode === "noaa") {
        if (gNoaaDayTimes && gNoaaDayTimes.length === 12) candidates = gNoaaDayTimes.slice();
      } else {
        const texts = NOAA_INPUT_IDS.map(id => document.getElementById(id)?.value || "");
        for (const txt of texts) {
          const v = parseBomValidTime(txt || "");
          if (v && !isNaN(v.getTime())) candidates.push(v);
        }
        candidates.sort((a,b)=>a-b);
      }

      if (!candidates.length) {
        const opt = document.createElement("option");
        opt.value = "";
        opt.textContent = "(候補なし)";
        sel.appendChild(opt);
        return;
      }

      for (const d of candidates) {
        const opt = document.createElement("option");
        opt.value = d.toISOString();
        opt.textContent = d.toISOString().replace(".000Z","Z");
        sel.appendChild(opt);
      }
      sel.value = candidates[0].toISOString();
    }

    /* ============================
     *  計算式表示
     * ============================ */
    function updateFormulaText() {
      const cfg = getConfigFromUI();
      const txt =
`BaseTEC = InputTEC − Sflare_base − Sstorm_base

ForecastTEC(t,lat,lon) =
  kBase * BaseTEC(t,lat,lon)
  + ΔStorm(t,lat) + ΔFlare(t,lat,lon)

ΔStorm = kStorm * (rStorm(KpF,lat,month) − 1) * BaseTEC
rStorm = 1 + f(KpF,lat,month) + tail(KpF)

ΔFlare = clamp( 15 * β_flare * (kX*Px + kM*Pm) * DayWeight(lat,lon,t), 0, 15 )

GPS_L1_error[m] = TEC * kL1

kBase=${cfg.kBase}, kStorm=${cfg.kStorm}, β=${cfg.betaFlare}, kX=${cfg.kX}, kM=${cfg.kM}, kL1=${cfg.kL1}`;
      const el = document.getElementById("formulaText");
      if (el) el.textContent = txt;
    }

    /* ============================
     *  Leaflet 初期化 & Canvas Overlay
     * ============================ */
    function initMap() {
      map = L.map("tecMap", {
        worldCopyJump: true,
        preferCanvas: true
      }).setView([20, 140], 3);

      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 8,
        attribution: "&copy; OpenStreetMap contributors"
      }).addTo(map);

      tecCanvas = document.createElement("canvas");
      tecCanvas.className = "tec-canvas-overlay";
      tecCtx = tecCanvas.getContext("2d", { alpha: true });
      document.getElementById("tecMap").appendChild(tecCanvas);

      const resize = () => {
        const size = map.getSize();
        tecCanvas.width = size.x;
        tecCanvas.height = size.y;
        tecCanvas.style.width = size.x + "px";
        tecCanvas.style.height = size.y + "px";
        invalidateProjectionCache();
        requestDraw();
      };

      map.on("resize", resize);
      map.on("move zoomend moveend", () => { invalidateProjectionCache(); requestDraw(); });
      resize();

      tecLegendControl = L.control({ position: "bottomright" });
      tecLegendControl.onAdd = function() {
        const div = L.DomUtil.create("div", "leaflet-control tec-legend");
        div.innerHTML = `
          <div class="tec-legend-title" id="legendTitle">TEC</div>
          <div class="tec-legend-bar" id="legendBar"></div>
          <div class="tec-legend-labels"><span>0</span><span id="legendMax">120</span></div>
        `;
        return div;
      };
      tecLegendControl.addTo(map);
      updateTecLegend();

      map.on("click", (e) => {
        showPointInfo(e.latlng);
      });
    }

    function updateTecLegend() {
      const title = document.getElementById("legendTitle");
      const bar = document.getElementById("legendBar");
      const max = document.getElementById("legendMax");
      if (!title || !bar || !max) return;

      const scale = (mapMode === "gps") ? gGpsColorScale : gTecColorScale;
      const label = (mapMode === "gps") ? "GPS" : "TEC";
      title.textContent = label;

      const stops = [];
      const last = scale[scale.length-1]?.limit ?? 1;
      max.textContent = String(last);

      let prev = 0;
      for (const s of scale) {
        const p0 = prev / last * 100;
        const p1 = s.limit / last * 100;
        stops.push(`${s.color} ${p0.toFixed(1)}%`);
        stops.push(`${s.color} ${p1.toFixed(1)}%`);
        prev = s.limit;
      }
      bar.style.background = `linear-gradient(to top, ${stops.join(",")})`;
    }

    function onTecAlphaChange() {
      tecAlpha = parseFloat(document.getElementById("tecAlpha").value) || 0.8;
      requestDraw();
    }
    function changeMapMode() {
      mapMode = document.getElementById("mapModeSelect").value || "tec";
      updateTecLegend();
      requestDraw();
    }

    /* ============================
     *  ★投影キャッシュ（lat/lon→px）で描画を高速化
     * ============================ */
    let _projCache = null;

    function invalidateProjectionCache() {
      _projCache = null;
    }

    function wrapLonNearCenter(lon, centerLon) {
      let x = lon;
      while (x - centerLon > 180) x -= 360;
      while (x - centerLon < -180) x += 360;
      return x;
    }

    function ensureProjectionCache() {
      if (!map || !gGrid) return null;

      const size = map.getSize();
      const zoom = map.getZoom();
      const centerLon = map.getCenter().lng;
      const centerLonKey = Math.round(centerLon * 1000) / 1000;

      const latArr = gGrid.latArr;
      const lonArr = gGrid.lonArr;
      const nLat = gGrid.nLat;
      const nLon = gGrid.nLon;

      const dLat = (nLat>1) ? (latArr[1]-latArr[0]) : 2;
      const dLon = (nLon>1) ? (lonArr[1]-lonArr[0]) : 5;

      // Leafletの世界幅（ズーム依存、概算でOK）
      const worldW = 256 * Math.pow(2, zoom);

      // キャッシュ妥当性
      if (_projCache &&
          _projCache.zoom === zoom &&
          _projCache.sizeX === size.x && _projCache.sizeY === size.y &&
          _projCache.centerLonKey === centerLonKey &&
          _projCache.nLat === nLat && _projCache.nLon === nLon &&
          _projCache.dLat === dLat && _projCache.dLon === dLon) {
        return _projCache;
      }

      // xEdges: lon境界を中心経度近傍にwrap → xを計算
      const xEdges = new Array(nLon + 1);
      for (let j=0;j<=nLon;j++) {
        const lonEdge = lonArr[0] + dLon * j;
        const lonW = wrapLonNearCenter(lonEdge, centerLon);
        // xはlonのみで決まる（Mercator）のでlat=0でOK
        const p = map.latLngToContainerPoint([0, lonW]);
        xEdges[j] = p.x;
      }

      // yEdges: lat境界（lonは中心でOK）
      const yEdges = new Array(nLat + 1);
      for (let i=0;i<=nLat;i++) {
        const latEdge = latArr[0] + dLat * i;
        const p = map.latLngToContainerPoint([latEdge, centerLon]);
        yEdges[i] = p.y;
      }

      _projCache = {
        zoom, sizeX:size.x, sizeY:size.y,
        centerLonKey,
        nLat, nLon, dLat, dLon,
        xEdges, yEdges,
        worldW
      };

      return _projCache;
    }

    function getColorFromScale(v, scale) {
      if (!isFinite(v)) return null;
      for (const s of scale) if (v <= s.limit) return s.color;
      return scale[scale.length-1].color;
    }

    function drawTecOverlay() {
      if (!map || !tecCtx || !tecCanvas) return;

      const size = map.getSize();
      tecCtx.clearRect(0,0,size.x,size.y);

      if (!gForecastFrames || !gForecastFrames.length || !gGrid) return;
      const frame = gForecastFrames[currentStepIndex];
      if (!frame) return;

      const cfg = getConfigFromUI();
      const scale = (mapMode === "gps") ? gGpsColorScale : gTecColorScale;

      const pc = ensureProjectionCache();
      if (!pc) return;

      const xE = pc.xEdges;
      const yE = pc.yEdges;
      const worldW = pc.worldW;

      tecCtx.globalAlpha = tecAlpha;

      // yは上が小さいので、セル描画は [i]→[i+1] を使う
      for (let i=0;i<pc.nLat;i++) {
        const y0 = yE[i];
        const y1 = yE[i+1];
        const y = Math.min(y0, y1);
        const h = Math.abs(y1 - y0);
        if (h < 0.2) continue;

        for (let j=0;j<pc.nLon;j++) {
          let v = frame[i][j];
          if (!isFinite(v)) continue;
          if (mapMode === "gps") v = v * cfg.kL1;

          const col = getColorFromScale(v, scale);
          if (!col) continue;

          let x0 = xE[j];
          let x1 = xE[j+1];

          // ★黒い影対策：datelineで x1 < x0 になる折返しを補正
          if (x1 < x0) x1 += worldW;

          // 画面近傍に正規化（過度な巨大rectを防ぐ）
          // 1回で足りないケースがあるので while
          while (x0 > size.x) { x0 -= worldW; x1 -= worldW; }
          while (x1 < 0)      { x0 += worldW; x1 += worldW; }

          const x = Math.min(x0, x1);
          const w = Math.abs(x1 - x0);
          if (w < 0.2) continue;

          // さらに巨大化した場合はスキップ（安全弁）
          if (w > worldW * 0.8) continue;

          tecCtx.fillStyle = col;
          tecCtx.fillRect(x, y, w, h);
        }
      }

      tecCtx.globalAlpha = 1.0;
    }

    function showPointInfo(latlng) {
      if (!gGrid || !gForecastFrames.length) return;
      const frame = gForecastFrames[currentStepIndex];
      if (!frame) return;

      const cfg = getConfigFromUI();

      let bestI=0, bestJ=0, bestD=1e99;
      const lonN = ((latlng.lng+540)%360-180);
      for (let i=0;i<gGrid.nLat;i++) {
        for (let j=0;j<gGrid.nLon;j++) {
          const d = Math.abs(gGrid.latArr[i]-latlng.lat) + Math.abs(gGrid.lonArr[j]-lonN);
          if (d < bestD) { bestD=d; bestI=i; bestJ=j; }
        }
      }

      const tec = frame[bestI][bestJ];
      const gps = isFinite(tec) ? tec * cfg.kL1 : NaN;
      const t = gForecastTimes[currentStepIndex] ? gForecastTimes[currentStepIndex].toISOString().replace(".000Z","Z") : "--";

      const out =
`UTC: ${t}
Nearest grid:
  lat=${gGrid.latArr[bestI].toFixed(1)}  lon=${gGrid.lonArr[bestJ].toFixed(1)}
TEC: ${isFinite(tec) ? tec.toFixed(2) : "NaN"} TECU
GPS L1 err: ${isFinite(gps) ? gps.toFixed(2) : "NaN"} m
`;
      document.getElementById("pointInfo").textContent = out;
    }

    /* ============================
     *  時間スライダー（rAF集約版）
     * ============================ */
    function onSliderChange() {
      currentStepIndex = parseInt(document.getElementById("timeSlider").value, 10) || 0;

      const h = (currentStepIndex * DT_MINUTES) / 60.0;
      const timeLabelEl = document.getElementById("timeLabel");
      if (timeLabelEl) timeLabelEl.textContent = `t = ${h.toFixed(1)} h`;

      const t = gForecastTimes[currentStepIndex];
      const utcLabelEl = document.getElementById("utcLabel");
      if (utcLabelEl) utcLabelEl.textContent = "UTC: " + (t ? t.toISOString().replace(".000Z","Z") : "--");

      let kpF = null;
      if (t) kpF = sampleSeriesAtUtc(gKpSeries, t, true);
      if (kpF == null) kpF = 3.0;

      let kpB = null;
      if (t) kpB = getKpBaseAtUtc(t, kpF);
      if (kpB == null) kpB = kpF;

      const kpNowEl = document.getElementById("kpNowLabel");
      if (kpNowEl) kpNowEl.textContent = `KpF=${(kpF!=null?kpF.toFixed(2):"--")} / KpB=${(kpB!=null?kpB.toFixed(2):"--")}`;

      // ★ここで直接drawしない（カクつき防止）
      requestDraw();
    }

    /* ============================
     *  地域フォーカス
     * ============================ */
    function focusRegion(key) {
      const regions = {
        japan:        { c:[36,138], z:4 },
        northAmerica: { c:[39,-98], z:4 },
        southAmerica: { c:[-15,-60], z:4 },
        europe:       { c:[52, 10], z:4 },
        africa:       { c:[ 5, 20], z:4 },
        australia:    { c:[-25,135], z:4 }
      };
      const r = regions[key];
      if (!r || !map) return;
      map.setView(r.c, r.z);
    }
    function applyManualFocus() {
      if (!map) return;
      const latMin = parseFloat(document.getElementById("focusLatMin").value);
      const latMax = parseFloat(document.getElementById("focusLatMax").value);
      const lonMin = parseFloat(document.getElementById("focusLonMin").value);
      const lonMax = parseFloat(document.getElementById("focusLonMax").value);
      if (![latMin,latMax,lonMin,lonMax].every(isFinite)) return;
      const b = L.latLngBounds([latMin, lonMin], [latMax, lonMax]);
      map.fitBounds(b, { padding:[10,10] });
    }
    function resetFocus() {
      if (!map) return;
      map.setView([20, 140], 3);
    }

    /* ============================
     *  入力フレームを「日周」で*
      * ============================ */
    function buildForecastTimes(startUtc) {
      gForecastStart = startUtc;
      gForecastTimes = [];
      for (let k=0;k<=N_STEPS;k++) {
        gForecastTimes.push(new Date(startUtc.getTime() + k*DT_MINUTES*60*1000));
      }
    }

    function chooseForecastStartUtc() {
      const sel = document.getElementById("forecastStartSelect");
      if (sel && sel.value) {
        const d = new Date(sel.value);
        if (!isNaN(d.getTime())) return d;
      }

      const mode = getTecSourceMode();
      if (mode === "noaa") {
        if (gNoaaDayTimes && gNoaaDayTimes.length) return gNoaaDayTimes[0];
      } else {
        // BoM: 最初に見つかったVALID TIME
        const texts = NOAA_INPUT_IDS.map(id => document.getElementById(id)?.value || "");
        for (const txt of texts) {
          const v = parseBomValidTime(txt);
          if (v && !isNaN(v.getTime())) return v;
        }
      }
      // fallback
      return new Date();
    }

    function getMonthFromUtc(d) {
      return (d instanceof Date) ? (d.getUTCMonth()+1) : 1; // 1..12
    }

    function cloneGridStructure(fromFrame) {
      gGrid = {
        latArr: fromFrame.latArr.slice(),
        lonArr: fromFrame.lonArr.slice(),
        nLat: fromFrame.nLat,
        nLon: fromFrame.nLon
      };
    }

    function getInputFrameAtUtc(tUtc) {
      const mode = getTecSourceMode();
      if (mode === "noaa") {
        // NOAA: 前日12枚の中から最近傍
        return sampleNoaaDayFrameAtUtc(tUtc);
      } else {
        // BoM: textarea 9枚をparseして最近傍
        const frames = parseBomInputs9();
        let best = frames[0], bestD = 1e99;
        for (const f of frames) {
          const t = f.validTime;
          if (!(t instanceof Date) || isNaN(t.getTime())) continue;
          const d = Math.abs(tUtc - t);
          if (d < bestD) { bestD = d; best = f; }
        }
        return best;
      }
    }

    function makeEmptyGrid(nLat, nLon, val=NaN) {
      return Array.from({length:nLat}, ()=>Array.from({length:nLon}, ()=>val));
    }

    function computeBaseTecGridAtStart(startUtc, cfg) {
      // InputTECをstart時刻でサンプル
      const inFrame = getInputFrameAtUtc(startUtc);
      if (!inFrame) throw new Error("入力TECフレームが取得できません（NOAA未取得/BoM未入力）");

      // Gridが未確定なら、入力に合わせて確定
      cloneGridStructure(inFrame);

      // Base用Kp/Flare series 読み込み
      gBaseKpSeries = parseBaseKpJson(document.getElementById("baseKpJson")?.value || "");
      gBaseFlareSeries = parseBaseFlareJson(document.getElementById("baseFlareJson")?.value || "");

      // 予報Kp series 読み込み（空ならデフォルト）
      gKpSeries = parseKpText(document.getElementById("noaaKpText")?.value || "");
      if (!gKpSeries.length) {
        // 何も無い時は固定3.0で回す
        const t0 = new Date(startUtc.getTime());
        gKpSeries = [{ time: t0, kp: 3.0 }];
      }

      // start時刻のKpF/KpB
      const kpF = sampleSeriesAtUtc(gKpSeries, startUtc, true) ?? 3.0;
      const kpB = getKpBaseAtUtc(startUtc, kpF);

      // Baseフレア（あれば近傍・なければ0）
      const bf = sampleFlareSeriesAtUtc(gBaseFlareSeries, startUtc);
      const PxB = bf.Px || 0;
      const PmB = bf.Pm || 0;

      const month = getMonthFromUtc(startUtc);

      // BaseTEC = InputTEC - Sstorm_base - Sflare_base
      const baseTec = makeEmptyGrid(gGrid.nLat, gGrid.nLon, NaN);

      for (let i=0;i<gGrid.nLat;i++) {
        const lat = gGrid.latArr[i];
        for (let j=0;j<gGrid.nLon;j++) {
          const lon = gGrid.lonArr[j];
          const inputTec = inFrame.grid[i]?.[j];
          if (!isFinite(inputTec)) { baseTec[i][j] = NaN; continue; }

          // Sstorm_base: kpBで計算（baseTecに掛ける前の近似として inputTecを一旦使う）
          // ※厳密にやるなら反復解だが、ここでは「差分抽出」に十分な精度でOK
          const dStormB = calcStormDelta(cfg, inputTec, lat, month, kpB);

          // Sflare_base: base flare Px/Pm で計算（最大15TECUで頭打ち）
          const dFlareB = calcFlareDeltaFromProbs(cfg, lat, lon, startUtc, PxB, PmB);

          const b = inputTec - dStormB - dFlareB;
          baseTec[i][j] = Math.max(0, b);
        }
      }
      return baseTec;
    }

    function computeForecastFrames(baseTecGrid, startUtc, cfg) {
      buildForecastTimes(startUtc);

      gForecastFrames = [];
      for (let k=0;k<=N_STEPS;k++) {
        gForecastFrames.push(makeEmptyGrid(gGrid.nLat, gGrid.nLon, NaN));
      }

      for (let k=0;k<=N_STEPS;k++) {
        const t = gForecastTimes[k];
        const kpF = sampleSeriesAtUtc(gKpSeries, t, true) ?? 3.0;
        const kpB = getKpBaseAtUtc(t, kpF);
        const month = getMonthFromUtc(t);

        for (let i=0;i<gGrid.nLat;i++) {
          const lat = gGrid.latArr[i];
          for (let j=0;j<gGrid.nLon;j++) {
            const lon = gGrid.lonArr[j];

            const baseTec = baseTecGrid[i][j];
            if (!isFinite(baseTec)) { gForecastFrames[k][i][j] = NaN; continue; }

            // ΔStorm（予報Kpで）
            const dStormF = calcStormDelta(cfg, baseTec, lat, month, kpF);

            // ΔFlare（Deep Flare Net の確率で）
            const dFlareF = calcFlareDeltaForecast(cfg, lat, lon, t);

            const tec = cfg.kBase * baseTec + dStormF + dFlareF;
            gForecastFrames[k][i][j] = tec;
          }
        }

        // UI表示用 Kp を最後にセット（重くない）
        if (k === currentStepIndex) {
          const kpNowEl = document.getElementById("kpNowLabel");
          if (kpNowEl) kpNowEl.textContent = `KpF=${kpF.toFixed(2)} / KpB=${kpB.toFixed(2)}`;
        }
      }
    }

    /* ============================
     *  実行：予報計算
     * ============================ */
    function runForecast() {
      try {
        const cfg = getConfigFromUI();

        const mode = getTecSourceMode();
        if (mode === "noaa") {
          if (!gNoaaDayFrames || !gNoaaDayFrames.length) {
            throw new Error("NOAA前日12枚が未取得です（先に『NOAA 解析前日…取得』を押してください）");
          }
        } else {
          const any = NOAA_INPUT_IDS.some(id => (document.getElementById(id)?.value || "").trim().length > 0);
          if (!any) throw new Error("BoM入力が空です（API取得 or コピペしてください）");
        }

        const startUtc = chooseForecastStartUtc();
        if (!(startUtc instanceof Date) || isNaN(startUtc.getTime())) throw new Error("予報開始時刻が不正です");

        logInfo("BaseTEC抽出中…");
        const baseTecGrid = computeBaseTecGridAtStart(startUtc, cfg);

        logInfo("4日予報を計算中…（格子×時間）");
        computeForecastFrames(baseTecGrid, startUtc, cfg);

        // スライダー設定
        const slider = document.getElementById("timeSlider");
        slider.min = 0;
        slider.max = N_STEPS;
        slider.value = 0;
        currentStepIndex = 0;
        onSliderChange();

        updateFormulaText();
        invalidateProjectionCache();
        requestDraw();

        logInfo("完了：4日予報を計算しました（スライダーで時刻を切替）。");
      } catch (e) {
        console.error(e);
        logInfo("失敗: " + e.message);
      }
    }

    /* ============================
     *  CSV出力（4日分）
     *  columns: utc,lat,lon,tec
     * ============================ */
    function exportTecCsv4day() {
      try {
        if (!gForecastFrames || !gForecastFrames.length || !gForecastTimes || !gGrid) {
          throw new Error("予報結果がありません（先に『TEC予報を計算』）");
        }
        let csv = "utc,lat,lon,tec\n";
        for (let k=0;k<gForecastFrames.length;k++) {
          const t = gForecastTimes[k]?.toISOString() || "";
          const frame = gForecastFrames[k];
          for (let i=0;i<gGrid.nLat;i++) {
            const lat = gGrid.latArr[i];
            for (let j=0;j<gGrid.nLon;j++) {
              const lon = gGrid.lonArr[j];
              const v = frame[i][j];
              if (!isFinite(v)) continue;
              csv += `${t},${lat.toFixed(6)},${lon.toFixed(6)},${v.toFixed(3)}\n`;
            }
          }
        }
        const blob = new Blob([csv], { type: "text/csv;charset=utf-8" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        const dayKey = gForecastStart ? gForecastStart.toISOString().slice(0,10) : "unknown";
        a.href = url;
        a.download = `SWIFTTEC_4day_${dayKey}_UTC.csv`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
        logInfo("CSVを書き出しました。");
      } catch (e) {
        console.error(e);
        logInfo("CSV出力失敗: " + e.message);
      }
    }

    /* ============================
     *  リセット
     * ============================ */
    function resetAll() {
      gForecastFrames = [];
      gForecastTimes = [];
      gForecastStart = null;
      currentStepIndex = 0;
      invalidateProjectionCache();
      requestDraw();
      logInfo("予報結果をリセットしました。");
    }

    /* ============================
     *  初期化
     * ============================ */
    function boot() {
      loadConfig(true);
      loadTecColorScaleFromStorage();
      loadGpsColorScaleFromStorage();
      loadBomInputsFromStorage();
      updateFormulaText();

      initMap();
      fillForecastStartCandidates();

      // 初期表示
      onSliderChange();
      requestDraw();

      // NOAA12枚が過去保存keyあるなら表だけ反映（実データは再取得が必要）
      renderNoaa12Table();
    }

    window.addEventListener("load", boot);
  </script>
</body>
</html>

