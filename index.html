<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>SWIFT-TEC v3 – TEC Forecast & Verification Tool (Leaflet版, 4日予報・加算＋Base抽出 / NOAA:2時間×12枚)</title>

  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #050816;
      color: #f5f5f5;
    }
    h1, h2, h3 { margin: 0 0 4px 0; letter-spacing: 0.03em; }
    h1 { font-size: 20px; }
    h2 { font-size: 16px; }
    h3 { font-size: 14px; }

    .page { display: flex; height: 100vh; }

    .sidebar {
      width: 430px;
      min-width: 360px;
      max-width: 520px;
      border-right: 1px solid #222b3f;
      padding: 10px;
      overflow-y: auto;
      background: radial-gradient(circle at top, #1c2740 0, #050814 55%, #050814 100%);
    }

    .main {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 10px;
      gap: 8px;
      min-width: 0;
      overflow-y: auto;
    }

    .card {
      background: rgba(10, 16, 32, 0.96);
      border: 1px solid #222b3f;
      border-radius: 8px;
      padding: 8px;
      margin-bottom: 4px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.25);
    }
    .card-header { display:flex; justify-content:space-between; align-items:center; margin-bottom:4px; }
    .card-header span { font-size: 11px; opacity: 0.7; }

    textarea {
      width: 100%;
      min-height: 60px;
      resize: vertical;
      font-size: 11px;
      padding: 4px;
      border-radius: 4px;
      border: 1px solid #334;
      background: #050814;
      color: #f5f5f5;
      font-family: "Consolas","Menlo",monospace;
    }
    input[type="number"], input[type="text"], input[type="color"], select {
      background: #050814;
      border-radius: 4px;
      border: 1px solid #334;
      color: #f5f5f5;
      font-size: 11px;
      padding: 2px 4px;
      font-family: inherit;
    }
    input[type="checkbox"] { transform: scale(0.9); }
    label { font-size: 11px; }

    .row { display:flex; gap:6px; margin-bottom:4px; align-items:center; flex-wrap:wrap; }
    .row > div { flex:1; min-width:80px; }

    button {
      border-radius: 4px;
      border: 1px solid #3b82f6;
      background: #1d4ed8;
      color: #f9fafb;
      padding: 3px 8px;
      font-size: 11px;
      cursor: pointer;
      font-weight: 500;
    }
    button.secondary { border-color:#4b5563; background:#111827; }
    button:disabled { opacity:0.4; cursor:default; }

    .small { font-size: 10px; opacity: 0.85; }

    pre {
      font-size: 11px;
      background: #050814;
      padding: 6px;
      border-radius: 4px;
      border: 1px solid #222b3f;
      white-space: pre-wrap;
    }
    table { width: 100%; border-collapse: collapse; font-size: 10px; }
    th, td { border: 1px solid #222b3f; padding: 2px 4px; text-align: left; }
    th { background: #111827; }

    .flex-col { display:flex; flex-direction:column; gap:4px; }

    .slider-card { flex:0 0 auto; }
    .map-card { flex: 1 1 auto; min-height: 55vh; display:flex; }
    .output-card { flex:0 0 auto; }

    .slider-row {
      display:flex; align-items:center; gap:8px;
      font-size: 11px; flex-wrap: wrap;
    }
    #timeSlider { flex:1; min-width:120px; }

    #tecMap {
      flex:1;
      height:100%;
      min-height:360px;
      border-radius:8px;
      overflow:hidden;
      position:relative;
    }
    .leaflet-container { background:#000; }
    .tec-canvas-overlay {
      position:absolute; top:0; left:0;
      pointer-events:none;
      z-index:400;
    }

    .leaflet-control.tec-legend {
      background: rgba(5, 8, 20, 0.95);
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid #222b3f;
      color: #f5f5f5;
      font-size: 10px;
      line-height: 1.3;
      box-shadow: 0 0 6px rgba(0,0,0,0.5);
    }
    .tec-legend-title { text-align:center; margin-bottom:4px; font-weight:600; letter-spacing:0.05em; }
    .tec-legend-bar { width:18px; height:130px; margin:0 auto 4px auto; border-radius:4px; border:1px solid #444; }
    .tec-legend-labels { display:flex; justify-content:space-between; font-size:9px; }

    .output-row { display:flex; gap:8px; align-items:stretch; flex-wrap:wrap; }
    .output-col { flex:1; min-width:200px; display:flex; flex-direction:column; }
    .output-col pre { max-height:220px; overflow-y:auto; }

    hr { border:none; border-top:1px solid #222b3f; margin:4px 0; }

    .focus-btn { width:100%; font-size:9px; padding:3px 2px; }
    .mono { font-family: "Consolas","Menlo",monospace; }

    .pill {
      display:inline-block;
      font-size:10px;
      padding:1px 6px;
      border:1px solid #334;
      border-radius: 999px;
      background:#050814;
      opacity:0.95;
    }
  </style>

  <!-- パスワード保護 -->
  <script>
    (function () {
      const PASSWORD = "Haneishi";
      const input = prompt("パスワードを入力してください");
      if (input !== PASSWORD) {
        alert("パスワードが違います");
        document.documentElement.innerHTML = "";
        throw new Error("Unauthorized");
      }
    })();
  </script>
</head>

<body>
  <div class="page">
    <!-- ============= サイドバー ============= -->
    <div class="sidebar">
      <div class="card">
        <div class="card-header">
          <h1>SWIFT-TEC v3</h1>
          <span>Global TEC Forecast (4-day, Base抽出＋加算)</span>
        </div>
        <div class="small">
          ・入力TECは <b>BoM</b> or <b>NOAA(GloTEC)</b> を選択<br>
          ・Base抽出＋加算モデル（要件の式）に更新：<b>ΔStorm = kStorm * BaseTEC * (rStorm - 1)</b><br>
          ・SStorm（rStorm）は <b>Mukhtarovベース（季節・緯度・Kp依存）＋スーパーストーム尾部 tail</b> を実装（簡易版禁止）<br>
          ・NOAA入力は <b>解析前日(UTC)の1日分</b> をAPI取得（<b>2時間おき12枚</b>）→ 2°×5°格子化<br>
          ・4日予報では NOAA12枚を <b>UTC時刻-of-dayで日周リピート</b>（模様が時間で動く）<br>
          ・今回の修正：<b>2時間→30分は線形補間</b>、BaseKp/Flareも<b>日周リピート＋線形補間</b><br>
        </div>
      </div>

      <!-- 0. 入力TECソース -->
      <div class="card">
        <div class="card-header">
          <h2>0. 入力TECソース</h2>
          <span>BoM / NOAA</span>
        </div>
        <div class="row">
          <div style="flex:1;">
            <label>TEC入力元</label><br>
            <select id="tecSourceSelect" style="width:100%;">
              <option value="bom">BoM (WorldXXXX_tec.txt 最大9枚)</option>
              <option value="noaa" selected>NOAA (GloTEC: 解析前日UTCの1日分=12枚, 2°×5°へ格子化)</option>
            </select>
          </div>
        </div>

        <div class="row">
          <button onclick="fetchNoaaGloTecPrevDay12_2hour(false)">NOAA 解析前日(UTC) 2時間おき12枚をAPI取得（メモリ保持）</button>
          <button class="secondary" onclick="fetchNoaaGloTecPrevDay12_2hour(true)">取得して保存（概要のみ）</button>
        </div>
        <div class="small" id="noaaTecStatus"></div>

        <div class="small" style="margin-top:6px;">
          <div class="row" style="gap:8px;">
            <span class="pill">NOAA12枚の一覧</span>
            <span class="pill" id="noaa12KeyPill">day: --</span>
          </div>
          <div style="max-height:160px; overflow:auto; border:1px solid #222b3f; border-radius:6px; padding:4px;">
            <table>
              <thead><tr><th>#</th><th>target(UTC)</th><th>file</th></tr></thead>
              <tbody id="noaa12TableBody">
                <tr><td colspan="3" class="small">未取得</td></tr>
              </tbody>
            </table>
          </div>
        </div>

        <div class="small" style="margin-top:6px;">
          ※一覧JSON（geojson_2d_urt.json）から前日(UTC) 00,02,…,22 の近傍ファイルを自動選定。<br>
          ※UIのtextareaはデバッグ9枠だけ表示（予報は12枠を内部使用）。
        </div>

        <div class="row" style="margin-top:6px;">
          <label class="small">
            <input type="checkbox" id="dbgNoaaMix" checked>
            デバッグ：NOAA補間のmix情報を runInfo に出す（重い場合OFF）
          </label>
        </div>
      </div>

      <!-- 1. TEC入力（テキスト貼付/保存用） -->
      <div class="card">
        <div class="card-header">
          <h2>1. TEC入力（テキスト貼付/保存用）</h2>
          <span>BoM or NOAA(デバッグ用9枠)</span>
        </div>

        <div class="small">
          ・BoMの場合：0000/0300/0600/0900/1200/1500/1800/2100/2330 の計9枚<br>
          ・NOAAの場合：ここは<b>デバッグ表示用（先頭9枚）</b><br>
          ・本命のNOAA運用は「0. NOAA 解析前日 12枚」ボタンでメモリに取り込みます
        </div>

        <div class="row">
          <button onclick="fetchBomTec9FromApi(false)">BoM 9枚をAPI取得 → 入力欄へ</button>
          <button class="secondary" onclick="fetchBomTec9FromApi(true)">取得して保存</button>
        </div>
        <div class="small" id="bomApiStatus"></div>

        <hr>

        <div class="row small"><div>Input #1</div><div>Input #2</div><div>Input #3</div></div>
        <div class="row">
          <div><textarea id="bomInput1" placeholder="# (BoM/NOAA)"></textarea></div>
          <div><textarea id="bomInput2"></textarea></div>
          <div><textarea id="bomInput3"></textarea></div>
        </div>
        <div class="row small"><div>Input #4</div><div>Input #5</div><div>Input #6</div></div>
        <div class="row">
          <div><textarea id="bomInput4"></textarea></div>
          <div><textarea id="bomInput5"></textarea></div>
          <div><textarea id="bomInput6"></textarea></div>
        </div>
        <div class="row small"><div>Input #7</div><div>Input #8</div><div>Input #9</div></div>
        <div class="row">
          <div><textarea id="bomInput7"></textarea></div>
          <div><textarea id="bomInput8"></textarea></div>
          <div><textarea id="bomInput9"></textarea></div>
        </div>
        <div class="row">
          <button onclick="saveBomInputs()">入力（BoM/NOAA）を保存</button>
          <button class="secondary" onclick="clearBomInputsStorage()">保存を削除</button>
        </div>
        <div class="small" id="bomInfo">※「入力を保存」を押した時点の内容をブラウザに保存。次回起動時に自動復元。</div>
      </div>

      <!-- 2. NOAA Kp テキスト（予報用） -->
      <div class="card">
        <div class="card-header">
          <h2>2. NOAA Kp テキスト（予報用）</h2>
          <span>3-Day Geomag Forecast</span>
        </div>
        <div class="small">
          ・Kp（3日予報）は、NOAAの <b>3-day geomag forecast (text)</b> を自動取得できます。
        </div>
        <div class="row">
          <button onclick="fetchNoaa3DayGeomagToTextarea()">NOAA 3-day（Kp）をAPI取得 → 貼付</button>
          <span class="small" id="noaa3dayStatus"></span>
        </div>
        <div class="row">
          <div>
            <label>Kp 予報テキスト（NOAA geomag forecast）</label><br>
            <textarea id="noaaKpText" placeholder="自動取得 or 手動貼付"></textarea>
          </div>
        </div>
      </div>

      <!-- 2b. Base作成用 Kp / フレア -->
      <div class="card">
        <div class="card-header">
          <h2>2b. Base 作成用 Kp / フレア</h2>
          <span>入力TECから嵐・フレア成分を引き算</span>
        </div>
        <div class="small">
          ・Base用 Kp：NOAA 実測 Kp の JSON 配列（1日分）を貼付 or API取得<br>
          ・Base用 フレア：NOAA最新 X-ray flare（M/X）をAPI取得して自動入力可能<br>
          ※空の場合：Kp は「予報用」を流用、フレアは 0 とみなす
        </div>

        <div class="row">
          <button onclick="fetchNoaaPlanetaryKIndex1DayToBase()">NOAA K-index（1日分）をAPI取得 → Base用Kpへ</button>
          <span class="small" id="kindexStatus"></span>
        </div>
        <div class="row">
          <button onclick="fetchNoaaXrayFlareLatestToBase()">NOAA 最新X-rayフレア（M/X）をAPI取得 → Base用フレアへ</button>
          <span class="small" id="xrayflareStatus"></span>
        </div>

        <div class="row">
          <div>
            <label>Base 用 Kp（JSON 配列）</label><br>
            <textarea id="baseKpJson" placeholder='[["time_tag","Kp","a_running","station_count"],["2025-11-26 00:00:00.000","3.33","18","8"], ...]'></textarea>
          </div>
        </div>
        <div class="row">
          <div>
            <label>Base 用 フレア（JSON, time / Px / Pm）</label><br>
            <textarea id="baseFlareJson" placeholder='[{"time":"2025-11-26T00:00:00Z","Px":5,"Pm":15}, ...]'></textarea>
          </div>
        </div>
      </div>

      <!-- 3. Deep Flare Net 9領域（予報用） -->
      <div class="card">
        <div class="card-header">
          <h2>3. Deep Flare Net 領域（予報用）</h2>
          <span>9分割フレア確率（3×3）</span>
        </div>
        <div class="small">
          太陽円盤を 3×3 の 9領域に分割し、各領域ごとの Xクラス / Mクラス発生確率 [%] を入力。<br>
          R1=北西, R2=北, R3=北東 / R4=西, R5=中央, R6=東 / R7=南西, R8=南, R9=南東
        </div>
        <table>
          <thead><tr><th>ID</th><th>位置</th><th>P(X≥)%</th><th>P(M≥)%</th><th>使用</th></tr></thead>
          <tbody>
            <tr><td>R1</td><td>北西</td><td><input id="fx1" type="number" value="0" style="width:50px;"></td><td><input id="fm1" type="number" value="10" style="width:50px;"></td><td><input id="fu1" type="checkbox" checked></td></tr>
            <tr><td>R2</td><td>北</td><td><input id="fx2" type="number" value="0" style="width:50px;"></td><td><input id="fm2" type="number" value="10" style="width:50px;"></td><td><input id="fu2" type="checkbox" checked></td></tr>
            <tr><td>R3</td><td>北東</td><td><input id="fx3" type="number" value="0" style="width:50px;"></td><td><input id="fm3" type="number" value="10" style="width:50px;"></td><td><input id="fu3" type="checkbox" checked></td></tr>
            <tr><td>R4</td><td>西</td><td><input id="fx4" type="number" value="0" style="width:50px;"></td><td><input id="fm4" type="number" value="10" style="width:50px;"></td><td><input id="fu4" type="checkbox" checked></td></tr>
            <tr><td>R5</td><td>中央</td><td><input id="fx5" type="number" value="0" style="width:50px;"></td><td><input id="fm5" type="number" value="10" style="width:50px;"></td><td><input id="fu5" type="checkbox" checked></td></tr>
            <tr><td>R6</td><td>東</td><td><input id="fx6" type="number" value="0" style="width:50px;"></td><td><input id="fm6" type="number" value="10" style="width:50px;"></td><td><input id="fu6" type="checkbox" checked></td></tr>
            <tr><td>R7</td><td>南西</td><td><input id="fx7" type="number" value="0" style="width:50px;"></td><td><input id="fm7" type="number" value="10" style="width:50px;"></td><td><input id="fu7" type="checkbox" checked></td></tr>
            <tr><td>R8</td><td>南</td><td><input id="fx8" type="number" value="0" style="width:50px;"></td><td><input id="fm8" type="number" value="10" style="width:50px;"></td><td><input id="fu8" type="checkbox" checked></td></tr>
            <tr><td>R9</td><td>南東</td><td><input id="fx9" type="number" value="0" style="width:50px;"></td><td><input id="fm9" type="number" value="10" style="width:50px;"></td><td><input id="fu9" type="checkbox" checked></td></tr>
          </tbody>
        </table>
      </div>

      <!-- 4. TEC カラーマップ設定 -->
      <div class="card">
        <div class="card-header"><h2>4. TEC カラーマップ設定</h2><span>TEC値 → 色</span></div>
        <div class="small">TEC [TECU] の上限と色を設定。色は地図と凡例に反映。</div>
        <table>
          <thead><tr><th>レベル</th><th>TEC上限</th><th>色</th></tr></thead>
          <tbody>
            <tr><td>L1</td><td><input id="tLimit1" type="number" value="10" style="width:60px;"></td><td><input id="tColor1" type="color" value="#00ff00"></td></tr>
            <tr><td>L2</td><td><input id="tLimit2" type="number" value="30" style="width:60px;"></td><td><input id="tColor2" type="color" value="#ffff00"></td></tr>
            <tr><td>L3</td><td><input id="tLimit3" type="number" value="60" style="width:60px;"></td><td><input id="tColor3" type="color" value="#ff9900"></td></tr>
            <tr><td>L4</td><td><input id="tLimit4" type="number" value="120" style="width:60px;"></td><td><input id="tColor4" type="color" value="#ff0000"></td></tr>
          </tbody>
        </table>
        <div class="row">
          <button onclick="applyTecColorScale()">TEC色を反映</button>
          <button class="secondary" onclick="resetTecColorScale()">初期化</button>
        </div>
      </div>

      <!-- 5. GPS L1誤差 カラーマップ設定 -->
      <div class="card">
        <div class="card-header"><h2>5. GPS L1誤差 カラーマップ</h2><span>誤差[m] → 色</span></div>
        <div class="small">L1即位誤差 [m] の上限と色を設定。TEC×kL1 で換算。</div>
        <table>
          <thead><tr><th>レベル</th><th>誤差上限</th><th>色</th></tr></thead>
          <tbody>
            <tr><td>L1</td><td><input id="gLimit1" type="number" value="5" style="width:60px;"></td><td><input id="gColor1" type="color" value="#00ff00"></td></tr>
            <tr><td>L2</td><td><input id="gLimit2" type="number" value="10" style="width:60px;"></td><td><input id="gColor2" type="color" value="#ffff00"></td></tr>
            <tr><td>L3</td><td><input id="gLimit3" type="number" value="20" style="width:60px;"></td><td><input id="gColor3" type="color" value="#ff9900"></td></tr>
            <tr><td>L4</td><td><input id="gLimit4" type="number" value="40" style="width:60px;"></td><td><input id="gColor4" type="color" value="#ff0000"></td></tr>
          </tbody>
        </table>
        <div class="row">
          <button onclick="applyGpsColorScale()">GPS色を反映</button>
          <button class="secondary" onclick="resetGpsColorScale()">初期化</button>
        </div>
      </div>

      <!-- 6. 係数設定 -->
      <div class="card">
        <div class="card-header"><h2>6. 係数設定（Advanced）</h2><span>Base / Storm / Flare / GPS / SStorm</span></div>
        <div class="small">
          ・ΔStorm倍率(kStorm)と、スーパーストーム尾部(tail)の係数(A0/Kc/w)は分離して調整できます。<br>
          ・SStorm（rStorm）は「倍率」。TECUに足し込むのは禁止（本コードは乗算→TECU化のみ）。
        </div>
        <div class="flex-col">
          <div class="row">
            <div><label>kBase（静穏ベース倍率）</label><br><input id="cfg_kBase" type="number" value="1.0" step="0.1"></div>
            <div><label>kStorm（ΔStorm倍率）</label><br><input id="cfg_kStorm" type="number" value="1.0" step="0.1"></div>
          </div>
          <div class="row">
            <div><label>β_flare</label><br><input id="cfg_betaFlare" type="number" value="0.7" step="0.05"></div>
            <div><label>k_X（Xフレア寄与）</label><br><input id="cfg_kX" type="number" value="1.0" step="0.1"></div>
            <div><label>k_M（Mフレア寄与）</label><br><input id="cfg_kM" type="number" value="0.5" step="0.1"></div>
          </div>
          <div class="row">
            <div><label>kL1（TEC→L1誤差[m/TECU]）</label><br><input id="cfg_kL1" type="number" value="0.16" step="0.01"></div>
          </div>

          <hr>

          <div class="row">
            <div><label>SStorm σ_lat [deg]</label><br><input id="cfg_sigmaLat" type="number" value="15.0" step="0.5"></div>
            <div><label>SStorm σ_m [month]</label><br><input id="cfg_sigmaM" type="number" value="2.0" step="0.1"></div>
          </div>
          <div class="row">
            <div style="flex:1.2;">
              <label class="small"><input id="cfg_useTail" type="checkbox" checked> tail を使用（スーパーストーム尾部）</label>
            </div>
            <div><label>tail Kc</label><br><input id="cfg_tailKc" type="number" value="6.5" step="0.1"></div>
            <div><label>tail w</label><br><input id="cfg_tailW" type="number" value="1.2" step="0.1"></div>
            <div><label>tail A0</label><br><input id="cfg_tailA0" type="number" value="0.01" step="0.005"></div>
          </div>
        </div>
        <div class="row">
          <button onclick="saveConfig()">設定を保存</button>
          <button class="secondary" onclick="loadConfig(true)">保存値を再読込</button>
        </div>
      </div>

      <!-- 7. 地域フォーカス -->
      <div class="card">
        <div class="card-header"><h2>7. 地域フォーカス</h2><span>地図ズーム</span></div>
        <div class="row">
          <button class="focus-btn" onclick="focusRegion('japan')">日本</button>
          <button class="focus-btn" onclick="focusRegion('northAmerica')">北アメリカ</button>
        </div>
        <div class="row">
          <button class="focus-btn" onclick="focusRegion('southAmerica')">南アメリカ</button>
          <button class="focus-btn" onclick="focusRegion('europe')">ヨーロッパ</button>
        </div>
        <div class="row">
          <button class="focus-btn" onclick="focusRegion('africa')">アフリカ</button>
          <button class="focus-btn" onclick="focusRegion('australia')">オーストラリア</button>
        </div>
        <hr>
        <div class="small">手動指定（緯度・経度 範囲）</div>
        <div class="row">
          <div><label>Lat min</label><br><input id="focusLatMin" type="number" value="-10" step="1"></div>
          <div><label>Lat max</label><br><input id="focusLatMax" type="number" value="50" step="1"></div>
        </div>
        <div class="row">
          <div><label>Lon min</label><br><input id="focusLonMin" type="number" value="120" step="1"></div>
          <div><label>Lon max</label><br><input id="focusLonMax" type="number" value="150" step="1"></div>
        </div>
        <div class="row">
          <button class="focus-btn" onclick="applyManualFocus()">手動フォーカス適用</button>
          <button class="focus-btn secondary" onclick="resetFocus()">全体表示</button>
        </div>
      </div>

      <!-- 8. 実行 -->
      <div class="card">
        <div class="card-header"><h2>8. 実行</h2><span>予報 & 描画</span></div>
        <div class="row small">
          <div style="flex:1;">
            予報スタート時刻（UTC）:<br>
            <select id="forecastStartSelect" style="width:100%;"></select>
          </div>
        </div>
        <div class="small" id="forecastStartInfo">
          入力（BoM/NOAA）を読み込むと候補が自動で入ります。未選択時は最も早い有効時刻から開始します。
        </div>
        <div class="row" style="margin-top:4px;">
          <button onclick="runForecast()">TEC予報を計算</button>
          <button class="secondary" onclick="resetAll()">リセット</button>
        </div>
        <div class="row" style="margin-top:4px;">
          <button onclick="exportTecCsv4day()">4日分TECをCSV出力</button>
        </div>
        <div id="runInfo" class="small"></div>
      </div>
    </div>

    <!-- ============= メイン領域 ============= -->
    <div class="main">
      <div class="card slider-card">
        <div class="slider-row">
          <span>時間スライダー（0〜4日 / 30分刻み）</span>
          <input type="range" id="timeSlider" min="0" max="192" value="0" oninput="onSliderChange()">
          <span id="timeLabel">t = 0.0 h</span>
          <span id="utcLabel">UTC: --</span>
          <span id="kpNowLabel">KpF=-- / KpB=--</span>
        </div>
        <div class="row small" style="margin-top:4px;">
          <div style="flex:1;">
            TEC透明度:
            <input id="tecAlpha" type="range" min="0.2" max="1" step="0.05" value="0.8" style="width:140px;" oninput="onTecAlphaChange()">
          </div>
          <div style="flex:1;">
            表示モード:
            <select id="mapModeSelect" onchange="changeMapMode()">
              <option value="tec">TEC [TECU]</option>
              <option value="gps">GPS L1誤差 [m]</option>
            </select>
          </div>
          <div style="flex:2;"><span class="small">※地図をズーム／ドラッグして任意地域の分布を確認できます。</span></div>
        </div>
      </div>

      <div class="card map-card"><div id="tecMap"></div></div>

      <div class="card output-card">
        <div class="output-row">
          <div class="output-col" style="flex:2;">
            <h3>9. 現在の計算式（毎ステップBase抽出＋加算モデル）</h3>
            <pre id="formulaText">(式をここに表示)</pre>
          </div>
          <div class="output-col" style="flex:1;">
            <h3>10. 現在の TEC / GPS値</h3>
            <pre id="pointInfo">地図上をクリックすると、その格子点のTEC・GPS L1誤差と位置が表示されます。</pre>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <script>
    /* ============================
     *  画面にJSエラーを出す（デバッグ）
     * ============================ */
    window.addEventListener("error", (ev) => {
      try {
        const msg = (ev && (ev.message || (ev.error && ev.error.message))) ? (ev.message || ev.error.message) : "unknown error";
        const div = document.getElementById("runInfo");
        if (div) div.textContent = "JSエラー: " + msg;
      } catch {}
    });

    /* ============================
     *  API endpoints
     * ============================ */
    const BOM_TEC_BASE_URL = "https://downloads.sws.bom.gov.au/data/Satellite/";
    const BOM_TEC_FILES_9 = [
      "World0000_tec.txt","World0300_tec.txt","World0600_tec.txt","World0900_tec.txt",
      "World1200_tec.txt","World1500_tec.txt","World1800_tec.txt","World2100_tec.txt","World2330_tec.txt"
    ];

    const NOAA_3DAY_GEOMAG_TEXT_URL = "https://services.swpc.noaa.gov/text/3-day-geomag-forecast.txt";
    const NOAA_PLANETARY_K_INDEX_URL = "https://services.swpc.noaa.gov/products/noaa-planetary-k-index.json";
    const NOAA_XRAY_FLARES_LATEST_URL = "https://services.swpc.noaa.gov/json/goes/primary/xray-flares-latest.json";

    const NOAA_GLOTEC_INDEX_URL = "https://services.swpc.noaa.gov/products/glotec/geojson_2d_urt.json";
    const NOAA_GLOTEC_BASE_URL  = "https://services.swpc.noaa.gov/products/glotec/geojson_2d_urt/";

    async function fetchText(url) {
      const res = await fetch(url, { cache: "no-store" });
      if (!res.ok) throw new Error(`HTTP ${res.status} for ${url}`);
      return await res.text();
    }
    async function fetchJson(url) {
      const res = await fetch(url, { cache: "no-store" });
      if (!res.ok) throw new Error(`HTTP ${res.status} for ${url}`);
      return await res.json();
    }
    function setStatus(id, msg) {
      const el = document.getElementById(id);
      if (el) el.textContent = msg || "";
    }

    /* ============================
     *  NOAA 前日(UTC) 2時間おき12枚（メモリ保持）
     * ============================ */
    const NOAA_INPUT_IDS = ["bomInput1","bomInput2","bomInput3","bomInput4","bomInput5","bomInput6","bomInput7","bomInput8","bomInput9"];

    let gNoaaDayFrames = null;  // length=12  (grid)
    let gNoaaDayTimes  = null;  // Date[12] (target times)
    let gNoaaDayFiles  = null;  // string[12]
    let gNoaaDayKey    = null;  // "YYYY-MM-DD" (UTC)

    // デバッグ9枚（textarea表示用）
    let gNoaaInputTimes = new Array(9).fill(null);
    let gNoaaInputFiles = new Array(9).fill(null);

    function basename(p) {
      const s = String(p || "");
      const parts = s.split("/");
      return parts[parts.length-1] || s;
    }

    function parseUtcFromFilename(fn) {
      const s = String(fn || "");
      const m = s.match(/(\d{8})T(\d{6})Z/i);
      if (!m) return null;
      const y = parseInt(m[1].slice(0,4),10);
      const mo= parseInt(m[1].slice(4,6),10);
      const d = parseInt(m[1].slice(6,8),10);
      const hh= parseInt(m[2].slice(0,2),10);
      const mm= parseInt(m[2].slice(2,4),10);
      const ss= parseInt(m[2].slice(4,6),10);
      return new Date(Date.UTC(y, mo-1, d, hh, mm, ss));
    }

    function toDayKeyUtc(d) {
      const y = d.getUTCFullYear();
      const m = String(d.getUTCMonth()+1).padStart(2,"0");
      const da= String(d.getUTCDate()).padStart(2,"0");
      return `${y}-${m}-${da}`;
    }

    function normalizeGloTecIndexJson(js) {
      if (Array.isArray(js)) return js;
      if (js && Array.isArray(js.files)) return js.files;
      if (js && Array.isArray(js.data)) return js.data;
      if (js && typeof js === "object") {
        for (const k of Object.keys(js)) if (Array.isArray(js[k])) return js[k];
      }
      return [];
    }

    function toPathString(x) {
      if (x == null) return "";
      if (typeof x === "string") return x;
      if (typeof x === "object") {
        return x.url || x.href || x.path || x.name || x.file || x.filename || "";
      }
      return String(x);
    }

    function buildFileObjects(list) {
      const files = [];
      for (const item of list) {
        const p0 = toPathString(item);
        if (!p0) continue;

        const fn = basename(p0);
        const tUtc = parseUtcFromFilename(fn) || parseUtcFromFilename(p0);
        if (!tUtc) continue;

        const url = (p0.startsWith("http://") || p0.startsWith("https://")) ? p0
                  : (p0.includes("/") ? ("https://services.swpc.noaa.gov/" + p0.replace(/^\/+/,""))
                                     : (NOAA_GLOTEC_BASE_URL + fn));
        files.push({ fn, tUtc, url });
      }
      files.sort((a,b)=>a.tUtc-b.tUtc);
      return files;
    }

    function pickPrevDayTargetsFromLatest(files, intervalMinutes) {
      if (!files.length) return null;

      const latest = files[files.length-1].tUtc;
      const latestDayStart = new Date(Date.UTC(latest.getUTCFullYear(), latest.getUTCMonth(), latest.getUTCDate(), 0,0,0));
      const prevDayStart = new Date(latestDayStart.getTime() - 24*3600*1000);

      const n = Math.round(24*60/intervalMinutes);
      const targets = [];
      for (let k=0;k<n;k++) targets.push(new Date(prevDayStart.getTime() + k*intervalMinutes*60*1000));
      return { prevDayStart, targets, prevKey: toDayKeyUtc(prevDayStart) };
    }

    function nearestFileForTime(files, tTarget, maxDiffMin=70) {
      let best = null, bestDiff = 1e99;
      for (const f of files) {
        const diff = Math.abs(f.tUtc - tTarget);
        if (diff < bestDiff) { bestDiff = diff; best = f; }
      }
      if (!best) return null;
      const maxMs = maxDiffMin * 60 * 1000;
      if (bestDiff > maxMs) return null;
      return best;
    }

    async function fetchAllWithLimit(urls, limit=6) {
      const out = new Array(urls.length);
      let idx = 0;

      async function worker() {
        while (idx < urls.length) {
          const i = idx++;
          out[i] = await fetchText(urls[i]);
        }
      }

      const workers = [];
      for (let k=0;k<Math.min(limit, urls.length); k++) workers.push(worker());
      await Promise.all(workers);
      return out;
    }

    function renderNoaa12Table() {
      const body = document.getElementById("noaa12TableBody");
      const pill = document.getElementById("noaa12KeyPill");
      if (pill) pill.textContent = "day: " + (gNoaaDayKey || "--");

      if (!body) return;
      body.innerHTML = "";
      if (!gNoaaDayTimes || !gNoaaDayFiles) {
        const tr = document.createElement("tr");
        tr.innerHTML = `<td colspan="3" class="small">未取得</td>`;
        body.appendChild(tr);
        return;
      }

      for (let i=0;i<gNoaaDayTimes.length;i++) {
        const t = gNoaaDayTimes[i];
        const fn = gNoaaDayFiles[i] || "";
        const tr = document.createElement("tr");
        tr.innerHTML = `<td class="mono">${String(i+1).padStart(2,"0")}</td>
                        <td class="mono">${t.toISOString().replace(".000Z","Z")}</td>
                        <td class="mono">${fn}</td>`;
        body.appendChild(tr);
      }
    }

    async function fetchNoaaGloTecPrevDay12_2hour(saveAfter=false) {
      try {
        const intervalMin = 120;  // 2時間
        const maxDiffMin  = 90;   // 余裕

        setStatus("noaaTecStatus", "NOAA GloTEC 一覧(JSON)取得中…");
        const idx = await fetchJson(NOAA_GLOTEC_INDEX_URL);

        const listRaw = normalizeGloTecIndexJson(idx).map(toPathString).filter(Boolean);
        const list = listRaw.filter(x => {
          const s = String(x).toLowerCase();
          return s.endsWith(".geojson") || s.includes(".geojson");
        });

        if (!list.length) {
          const hint = Array.isArray(listRaw) ? listRaw.slice(0, 8).join(" / ") : "";
          throw new Error("一覧JSONから geojson が見つかりません（仕様変更/障害の可能性）。先頭例: " + hint);
        }

        const files = buildFileObjects(list);
        if (!files.length) throw new Error("ファイル名からUTCが抽出できません（命名規則が想定外）");

        const meta = pickPrevDayTargetsFromLatest(files, intervalMin);
        if (!meta) throw new Error("前日ターゲット生成に失敗");

        const { targets, prevKey } = meta;

        const picks = [];
        for (const t of targets) picks.push(nearestFileForTime(files, t, maxDiffMin));

        const prevDayFiles = files.filter(f => toDayKeyUtc(f.tUtc) === prevKey);
        for (let i=0;i<picks.length;i++) {
          if (picks[i]) continue;
          const alt = nearestFileForTime(prevDayFiles, targets[i], 240);
          picks[i] = alt || null;
        }

        if (picks.some(x=>!x)) {
          const miss = picks.filter(x=>!x).length;
          throw new Error(`前日(UTC)の${targets.length}枠のうち ${miss} 枠が取得不能（一覧欠損/メンテ等）`);
        }

        if (gNoaaDayKey === prevKey && gNoaaDayFrames && gNoaaDayFrames.length === targets.length) {
          setStatus("noaaTecStatus", `既にメモリに保持済み: NOAA 前日(UTC)=${prevKey}（${targets.length}枚）`);
          renderNoaa12Table();
          fillForecastStartCandidates();
          return;
        }

        setStatus("noaaTecStatus", `前日(UTC)=${prevKey} を${targets.length}枚取得中…（2時間おき）`);

        const urls = picks.map(x => x.url);
        const texts = await fetchAllWithLimit(urls, 6);

        const frames = [];
        for (let i=0;i<targets.length;i++) {
          const vt = targets[i];
          const f = parseNoaaGloTecGeoJson(texts[i], vt, 2.0, 5.0);
          frames.push(f);
        }

        gNoaaDayFrames = frames;
        gNoaaDayTimes  = targets.slice();
        gNoaaDayFiles  = picks.map(x=>x.fn);
        gNoaaDayKey    = prevKey;

        // デバッグ表示（textareaは先頭9枚だけ）
        for (let k=0;k<9;k++) {
          const ta = document.getElementById(NOAA_INPUT_IDS[k]);
          if (ta) ta.value = texts[k] || "";
          gNoaaInputTimes[k] = targets[k] || null;
          gNoaaInputFiles[k] = picks[k]?.fn || null;
        }

        if (saveAfter) saveBomInputs();

        setStatus("noaaTecStatus", `NOAA 前日(UTC)=${prevKey} を${targets.length}枚メモリ保持OK（予報は日周として使用/線形補間）`);
        renderNoaa12Table();
        fillForecastStartCandidates();
      } catch (e) {
        console.error(e);
        setStatus("noaaTecStatus", "失敗: " + e.message);
      }
    }

    /* ============================
     *  BoM 9枚 API取得
     * ============================ */
    async function fetchBomTec9FromApi(saveAfter=false) {
      try {
        setStatus("bomApiStatus", "BoM TEC を取得中…（9枚）");
        const texts = await Promise.all(
          BOM_TEC_FILES_9.map(fn => fetchText(BOM_TEC_BASE_URL + fn))
        );
        const ids = NOAA_INPUT_IDS;
        for (let i=0;i<ids.length;i++) {
          const ta = document.getElementById(ids[i]);
          if (ta) ta.value = texts[i] || "";
        }
        const times = texts.map(t => {
          const d = parseBomValidTime(t);
          return d ? d.toISOString().replace(".000Z","Z") : "--";
        });
        setStatus("bomApiStatus", "BoM API取得OK: " + times.join(" / "));
        if (saveAfter) saveBomInputs();
        fillForecastStartCandidates();
      } catch (e) {
        console.error(e);
        setStatus("bomApiStatus", "BoM API取得失敗: " + e.message + "（CORS制限なら手動コピペ運用）");
      }
    }

    async function fetchNoaa3DayGeomagToTextarea() {
      try {
        setStatus("noaa3dayStatus", "取得中…");
        const txt = await fetchText(NOAA_3DAY_GEOMAG_TEXT_URL);
        const ta = document.getElementById("noaaKpText");
        if (ta) ta.value = txt;
        setStatus("noaa3dayStatus", "OK");
      } catch (e) {
        console.error(e);
        setStatus("noaa3dayStatus", "失敗: " + e.message);
      }
    }

    async function fetchNoaaPlanetaryKIndex1DayToBase() {
      try {
        setStatus("kindexStatus", "取得中…");
        const data = await fetchJson(NOAA_PLANETARY_K_INDEX_URL);
        const ta = document.getElementById("baseKpJson");
        if (ta) ta.value = JSON.stringify(data);
        setStatus("kindexStatus", "OK（Base用Kpへ反映）");
      } catch (e) {
        console.error(e);
        setStatus("kindexStatus", "失敗: " + e.message);
      }
    }

    function parseFlareClass(cls) {
      const s = String(cls || "").trim().toUpperCase();
      if (!s) return null;
      const head = s[0];
      if (head !== "M" && head !== "X") return null;
      const mag = parseFloat(s.slice(1));
      return { head, mag: isFinite(mag) ? mag : 1.0 };
    }

    async function fetchNoaaXrayFlareLatestToBase() {
      try {
        setStatus("xrayflareStatus", "取得中…");
        const arr = await fetchJson(NOAA_XRAY_FLARES_LATEST_URL);
        if (!Array.isArray(arr) || arr.length === 0) {
          setStatus("xrayflareStatus", "データなし");
          return;
        }

        const f = arr[0];
        const cls = f.max_class || f.current_class || "";
        const p = parseFlareClass(cls);

        if (!p) {
          document.getElementById("baseFlareJson").value = JSON.stringify([]);
          setStatus("xrayflareStatus", `C以下（${cls || "N/A"}）→ Baseフレア=0`);
          return;
        }

        let strength01 = 0;
        if (p.head === "M") strength01 = Math.min(0.9, 0.2 + 0.08 * p.mag);
        else strength01 = 1.0;

        const Px = (p.head === "X") ? (strength01 * 100) : 0;
        const Pm = (p.head === "M") ? (strength01 * 100) : 0;

        const t = toUtcDateFromSwpcTimeTag(f.time_tag || f.max_time || f.peak_time || "");

        const obj = [{
          time: t ? t.toISOString() : new Date().toISOString(),
          Px: +Px.toFixed(2),
          Pm: +Pm.toFixed(2)
        }];

        document.getElementById("baseFlareJson").value = JSON.stringify(obj, null, 2);
        setStatus("xrayflareStatus", `OK: ${cls} → Px=${obj[0].Px}, Pm=${obj[0].Pm}`);
      } catch (e) {
        console.error(e);
        setStatus("xrayflareStatus", "失敗: " + e.message);
      }
    }

    /* ============================
     *  グローバル状態
     * ============================ */
    const FORECAST_HOURS = 24 * 4; // 4日
    const DT_MINUTES     = 30;
    const N_STEPS = Math.round(FORECAST_HOURS * 60 / DT_MINUTES); // 192

    let gGrid = null;              // {latArr, lonArr, nLat, nLon}
    let gForecastFrames = [];      // [step][i][j]
    let gForecastTimes  = [];      // Date[N_STEPS+1]
    let gForecastStart  = null;    // Date
    let currentStepIndex = 0;

    let gTecColorScale = [
      { limit: 10,  color: "#00ff00" },
      { limit: 30,  color: "#ffff00" },
      { limit: 60,  color: "#ff9900" },
      { limit: 120, color: "#ff0000" }
    ];
    let gGpsColorScale = [
      { limit: 5,  color: "#00ff00" },
      { limit: 10, color: "#ffff00" },
      { limit: 20, color: "#ff9900" },
      { limit: 40, color: "#ff0000" }
    ];

    let gKpSeries        = []; // 予報Kp（絶対時刻）
    let gBaseKpSeries    = []; // BaseKp（絶対時刻 1日分想定）
    let gBaseFlareSeries = []; // Base flare（絶対時刻 1日分想定）

    // ★日周補間用に前処理した配列（runForecastで作る）
    let gBaseKpTod = null;       // {mins:number[], vals:number[]}
    let gBaseFlareTod = null;    // {mins:number[], Px:number[], Pm:number[]}

    let map = null;
    let tecCanvas = null;
    let tecCtx = null;
    let tecLegendControl = null;
    let tecAlpha = 0.8;
    let mapMode = "tec";

    const STORAGE_KEY_CONFIG   = "swifttec_config_v4_additive_base_sstorm";
    const STORAGE_KEY_BOM      = "swifttec_inputs_v9_noaa_prevday12_2h";
    const STORAGE_KEY_TCOL     = "swifttec_teccol_v3";
    const STORAGE_KEY_GCOL     = "swifttec_gpscol_v1";

    function logInfo(msg) {
      const div = document.getElementById("runInfo");
      if (div) div.textContent = msg;
      console.log(msg);
    }
    function clamp(v, a, b) { return v < a ? a : (v > b ? b : v); }

    /* ============================
     *  ★描画をrAFでまとめる（スライダー軽量化）
     * ============================ */
    let _drawQueued = false;
    function requestDraw() {
      if (_drawQueued) return;
      _drawQueued = true;
      requestAnimationFrame(() => {
        _drawQueued = false;
        drawTecOverlay();
      });
    }

    /* ===== VALID DATE/TIME: 11/11/2025 00:00:00UTC ===== */
    function parseBomValidTime(text) {
      const lines = String(text || "").split(/\r?\n/);
      for (const line of lines) {
        const m = line.match(/VALID DATE\/TIME:\s*(\d{1,2})\/(\d{1,2})\/(\d{4})\s+(\d{1,2}):(\d{2}):(\d{2})/i);
        if (m) {
          const d  = parseInt(m[1],10);
          const mo = parseInt(m[2],10);
          const y  = parseInt(m[3],10);
          const hh = parseInt(m[4],10);
          const mm = parseInt(m[5],10);
          const ss = parseInt(m[6],10);
          return new Date(Date.UTC(y, mo-1, d, hh, mm, ss));
        }
      }
      return null;
    }

    /* ====== BoM TEC テキスト → 格子データ ====== */
    function parseBoM(text) {
      const lines = String(text || "").split(/\r?\n/).filter(l => l.trim().length > 0);
      if (!lines.length) throw new Error("空のテキストです。");

      let latMin, latMax, latStep, nLat;
      let lonMin, lonMax, lonStep, nLon;

      for (const line of lines) {
        if (/LATITUDE GRID/i.test(line)) {
          const m = line.match(/LATITUDE GRID.*:\s*([-\d.]+)\s+([-\d.]+)\s+([-\d.]+)\s+(\d+)/i);
          if (m) {
            latMin  = parseFloat(m[1]);
            latMax  = parseFloat(m[2]);
            latStep = parseFloat(m[3]);
            nLat    = parseInt(m[4],10);
          }
        } else if (/LONGITUDE GRID/i.test(line)) {
          const m = line.match(/LONGITUDE GRID.*:\s*([-\d.]+)\s+([-\d.]+)\s+([-\d.]+)\s+(\d+)/i);
          if (m) {
            lonMin  = parseFloat(m[1]);
            lonMax  = parseFloat(m[2]);
            lonStep = parseFloat(m[3]);
            nLon    = parseInt(m[4],10);
          }
        }
      }
      if (latMin === undefined || lonMin === undefined) {
        throw new Error("LATITUDE/LONGITUDE GRID 情報が見つかりません。");
      }

      const valLines = lines.filter(l => !l.trim().startsWith("#") && !/GRID/i.test(l));
      const values = [];
      for (const ln of valLines) {
        const parts = ln.split(/[, ]+/).map(x => x.trim()).filter(x => x.length>0);
        for (const p of parts) {
          const v = parseFloat(p);
          if (!isNaN(v)) values.push(v);
        }
      }
      if (values.length !== nLat*nLon) {
        throw new Error(`データ数が不一致です: ${values.length} vs ${nLat*nLon}`);
      }

      const latArr = [];
      for (let i=0;i<nLat;i++) latArr.push(latMin + latStep*i);

      const lonArr = [];
      for (let j=0;j<nLon;j++) lonArr.push(lonMin + lonStep*j);

      const grid = new Array(nLat);
      let idx = 0;
      for (let i=0;i<nLat;i++) {
        grid[i] = new Array(nLon);
        for (let j=0;j<nLon;j++) grid[i][j] = values[idx++];
      }

      const validTime = parseBomValidTime(text);
      return { latArr, lonArr, nLat, nLon, grid, validTime };
    }

    /* ============================
     *  NOAA GloTEC GeoJSON → 2°×5° Grid
     * ============================ */
    function parseNoaaGloTecGeoJson(text, validTimeFromFilename=null, targetLatStep=2.0, targetLonStep=5.0) {
      let obj;
      try { obj = JSON.parse(text); } catch { throw new Error("NOAA GeoJSONがJSONとして読めません"); }
      if (!obj || !Array.isArray(obj.features)) throw new Error("NOAA GeoJSON featuresが見つかりません");

      const candidateKeys = ["tec","vtec","VTEC","TEC","value","Value","grid_value","gridValue","tecu","TECU"];
      let valueKey = null;

      for (const f of obj.features) {
        const p = f && f.properties;
        if (!p) continue;
        for (const k of candidateKeys) {
          if (p[k] !== undefined && isFinite(parseFloat(p[k]))) { valueKey = k; break; }
        }
        if (valueKey) break;
      }
      if (!valueKey) {
        for (const f of obj.features) {
          const p = f && f.properties;
          if (!p) continue;
          for (const k of Object.keys(p)) {
            const v = parseFloat(p[k]);
            if (isFinite(v)) { valueKey = k; break; }
          }
          if (valueKey) break;
        }
      }
      if (!valueKey) throw new Error("TEC値プロパティが特定できません（propertiesに数値が無い）");

      const pts = [];
      for (const f of obj.features) {
        if (!f || !f.geometry) continue;
        let v = parseFloat(f.properties?.[valueKey]);
        if (!isFinite(v)) continue;

        v = Math.floor(v);
        if (v < 0) v = 0;

        const g = f.geometry;
        if (g.type === "Point" && Array.isArray(g.coordinates) && g.coordinates.length >= 2) {
          let lon = +g.coordinates[0];
          let lat = +g.coordinates[1];
          if (!isFinite(lat) || !isFinite(lon)) continue;
          lon = ((lon + 180) % 360) - 180;
          pts.push({ lat, lon, tec: v });
          continue;
        }

        let coords = null;
        if (g.type === "Polygon") coords = g.coordinates?.[0];
        else if (g.type === "MultiPolygon") coords = g.coordinates?.[0]?.[0];

        if (!Array.isArray(coords) || coords.length < 3) continue;

        let sumLon=0, sumLat=0, n=0;
        for (const c of coords) {
          if (!Array.isArray(c) || c.length < 2) continue;
          const lon = +c[0], lat = +c[1];
          if (!isFinite(lat) || !isFinite(lon)) continue;
          sumLon += lon; sumLat += lat; n++;
        }
        if (n===0) continue;
        let lonC = sumLon/n;
        lonC = ((lonC + 180) % 360) - 180;
        pts.push({ lat: sumLat/n, lon: lonC, tec: v });
      }

      if (!pts.length) throw new Error("GeoJSONから格子点が作れませんでした（Point/Polygonが想定外？）");

      const latArr = [];
      for (let lat=-90; lat<=90+1e-9; lat+=targetLatStep) latArr.push(+lat.toFixed(6));

      const lonArr = [];
      for (let lon=-180; lon<=180-1e-9; lon+=targetLonStep) lonArr.push(+lon.toFixed(6)); // -180..175

      const nLat = latArr.length, nLon = lonArr.length;
      const grid = Array.from({length:nLat}, ()=>Array.from({length:nLon}, ()=>NaN));

      // ※高速化余地あり。まずは確実性優先。
      for (let i=0;i<nLat;i++) {
        const lat0 = latArr[i];
        for (let j=0;j<nLon;j++) {
          const lon0 = lonArr[j];

          let best=null, bestD=1e99;
          for (const p of pts) {
            let dLon = Math.abs(p.lon - lon0);
            dLon = Math.min(dLon, 360 - dLon);
            const d = Math.abs(p.lat - lat0) + dLon;
            if (d < bestD) { bestD = d; best = p; }
          }
          grid[i][j] = best ? best.tec : NaN;
        }
      }

      const validTime = (validTimeFromFilename instanceof Date && !isNaN(validTimeFromFilename.getTime()))
        ? validTimeFromFilename
        : null;

      return { latArr, lonArr, nLat, nLon, grid, validTime };
    }

    /* ============ 入力保存 ============ */
    function saveBomInputs() {
      const data = {
        tecSource: document.getElementById("tecSourceSelect")?.value || "bom",
        bomInput1: document.getElementById("bomInput1").value,
        bomInput2: document.getElementById("bomInput2").value,
        bomInput3: document.getElementById("bomInput3").value,
        bomInput4: document.getElementById("bomInput4").value,
        bomInput5: document.getElementById("bomInput5").value,
        bomInput6: document.getElementById("bomInput6").value,
        bomInput7: document.getElementById("bomInput7").value,
        bomInput8: document.getElementById("bomInput8").value,
        bomInput9: document.getElementById("bomInput9").value,
        noaaTimes: (gNoaaInputTimes || []).map(d => (d instanceof Date && !isNaN(d.getTime())) ? d.toISOString() : null),
        noaaFiles: (gNoaaInputFiles || []).map(x => x || null),
        noaaPrevDayKey: gNoaaDayKey || null
      };
      localStorage.setItem(STORAGE_KEY_BOM, JSON.stringify(data));
      logInfo("入力（BoM/NOAA）を保存しました。（次回起動時に自動復元）");
    }

    function loadBomInputsFromStorage() {
      const s = localStorage.getItem(STORAGE_KEY_BOM);
      if (!s) return;
      try {
        const data = JSON.parse(s);
        if (data.tecSource) document.getElementById("tecSourceSelect").value = data.tecSource;

        if (data.bomInput1 !== undefined) document.getElementById("bomInput1").value = data.bomInput1;
        if (data.bomInput2 !== undefined) document.getElementById("bomInput2").value = data.bomInput2;
        if (data.bomInput3 !== undefined) document.getElementById("bomInput3").value = data.bomInput3;
        if (data.bomInput4 !== undefined) document.getElementById("bomInput4").value = data.bomInput4;
        if (data.bomInput5 !== undefined) document.getElementById("bomInput5").value = data.bomInput5;
        if (data.bomInput6 !== undefined) document.getElementById("bomInput6").value = data.bomInput6;
        if (data.bomInput7 !== undefined) document.getElementById("bomInput7").value = data.bomInput7;
        if (data.bomInput8 !== undefined) document.getElementById("bomInput8").value = data.bomInput8;
        if (data.bomInput9 !== undefined) document.getElementById("bomInput9").value = data.bomInput9;

        if (Array.isArray(data.noaaTimes)) {
          gNoaaInputTimes = data.noaaTimes.map(x => {
            if (!x) return null;
            const d = new Date(x);
            return isNaN(d.getTime()) ? null : d;
          });
          while (gNoaaInputTimes.length < 9) gNoaaInputTimes.push(null);
          gNoaaInputTimes = gNoaaInputTimes.slice(0,9);
        }
        if (Array.isArray(data.noaaFiles)) {
          gNoaaInputFiles = data.noaaFiles.map(x => x || null);
          while (gNoaaInputFiles.length < 9) gNoaaInputFiles.push(null);
          gNoaaInputFiles = gNoaaInputFiles.slice(0,9);
        }
        if (data.noaaPrevDayKey) gNoaaDayKey = data.noaaPrevDayKey;
      } catch(e) {
        console.warn("入力の復元に失敗:", e);
      }
    }

    function clearBomInputsStorage() {
      localStorage.removeItem(STORAGE_KEY_BOM);
      logInfo("保存されていた 入力（BoM/NOAA）を削除しました。（テキスト内容はそのまま）");
    }

    /* ============ Config（係数） ============ */
    function getConfigFromUI() {
      return {
        kBase:     parseFloat(document.getElementById("cfg_kBase").value)     || 1.0,
        kStorm:    parseFloat(document.getElementById("cfg_kStorm").value)    || 1.0,
        betaFlare: parseFloat(document.getElementById("cfg_betaFlare").value) || 0.7,
        kX:        parseFloat(document.getElementById("cfg_kX").value)        || 1.0,
        kM:        parseFloat(document.getElementById("cfg_kM").value)        || 0.5,
        kL1:       parseFloat(document.getElementById("cfg_kL1").value)       || 0.16,

        // SStorm options (override-able)
        sigmaLat:  parseFloat(document.getElementById("cfg_sigmaLat").value)  || 15.0,
        sigmaM:    parseFloat(document.getElementById("cfg_sigmaM").value)    || 2.0,
        useTail:   !!document.getElementById("cfg_useTail").checked,
        tailKc:    parseFloat(document.getElementById("cfg_tailKc").value)    || 6.5,
        tailW:     parseFloat(document.getElementById("cfg_tailW").value)     || 1.2,
        tailA0:    parseFloat(document.getElementById("cfg_tailA0").value)    || 0.01,
      };
    }

    function applyConfigToUI(cfg) {
      document.getElementById("cfg_kBase").value     = cfg.kBase     ?? 1.0;
      document.getElementById("cfg_kStorm").value    = cfg.kStorm    ?? 1.0;
      document.getElementById("cfg_betaFlare").value = cfg.betaFlare ?? 0.7;
      document.getElementById("cfg_kX").value        = cfg.kX        ?? 1.0;
      document.getElementById("cfg_kM").value        = cfg.kM        ?? 0.5;
      document.getElementById("cfg_kL1").value       = cfg.kL1       ?? 0.16;

      document.getElementById("cfg_sigmaLat").value  = cfg.sigmaLat  ?? 15.0;
      document.getElementById("cfg_sigmaM").value    = cfg.sigmaM    ?? 2.0;
      document.getElementById("cfg_useTail").checked = (cfg.useTail ?? true);

      document.getElementById("cfg_tailKc").value    = cfg.tailKc    ?? 6.5;
      document.getElementById("cfg_tailW").value     = cfg.tailW     ?? 1.2;
      document.getElementById("cfg_tailA0").value    = cfg.tailA0    ?? 0.01;

      updateFormulaText();
    }

    function saveConfig() {
      const cfg = getConfigFromUI();
      localStorage.setItem(STORAGE_KEY_CONFIG, JSON.stringify(cfg));
      logInfo("係数設定を保存しました。");
      updateFormulaText();
      requestDraw();
    }

    function loadConfig(apply) {
      const s = localStorage.getItem(STORAGE_KEY_CONFIG);
      if (!s) {
        if (apply) {
          updateFormulaText();
          logInfo("保存された係数がありません。初期値を使用。");
        }
        return null;
      }
      try {
        const cfg = JSON.parse(s);
        if (apply) applyConfigToUI(cfg);
        return cfg;
      } catch(e) {
        console.warn("Configの復元に失敗:", e);
        return null;
      }
    }

    /* ============ TEC / GPS カラーマップ設定（そのまま） ============ */
    function applyTecColorScale() {
      const limits = [
        parseFloat(document.getElementById("tLimit1").value) || 10,
        parseFloat(document.getElementById("tLimit2").value) || 30,
        parseFloat(document.getElementById("tLimit3").value) || 60,
        parseFloat(document.getElementById("tLimit4").value) || 120
      ];
      const cols = [
        document.getElementById("tColor1").value || "#00ff00",
        document.getElementById("tColor2").value || "#ffff00",
        document.getElementById("tColor3").value || "#ff9900",
        document.getElementById("tColor4").value || "#ff0000"
      ];
      gTecColorScale = [
        { limit: limits[0], color: cols[0] },
        { limit: limits[1], color: cols[1] },
        { limit: limits[2], color: cols[2] },
        { limit: limits[3], color: cols[3] }
      ];
      localStorage.setItem(STORAGE_KEY_TCOL, JSON.stringify(gTecColorScale));
      logInfo("TECカラースケールを保存しました。");
      updateTecLegend();
      requestDraw();
    }

    function resetTecColorScale() {
      gTecColorScale = [
        { limit: 10,  color: "#00ff00" },
        { limit: 30,  color: "#ffff00" },
        { limit: 60,  color: "#ff9900" },
        { limit: 120, color: "#ff0000" }
      ];
      document.getElementById("tLimit1").value = 10;
      document.getElementById("tLimit2").value = 30;
      document.getElementById("tLimit3").value = 60;
      document.getElementById("tLimit4").value = 120;
      document.getElementById("tColor1").value = "#00ff00";
      document.getElementById("tColor2").value = "#ffff00";
      document.getElementById("tColor3").value = "#ff9900";
      document.getElementById("tColor4").value = "#ff0000";
      localStorage.setItem(STORAGE_KEY_TCOL, JSON.stringify(gTecColorScale));
      updateTecLegend();
      requestDraw();
    }

    function loadTecColorScaleFromStorage() {
      const s = localStorage.getItem(STORAGE_KEY_TCOL);
      if (!s) return;
      try {
        const arr = JSON.parse(s);
        if (!Array.isArray(arr) || arr.length !== 4) return;
        gTecColorScale = arr;
        document.getElementById("tLimit1").value = arr[0].limit;
        document.getElementById("tLimit2").value = arr[1].limit;
        document.getElementById("tLimit3").value = arr[2].limit;
        document.getElementById("tLimit4").value = arr[3].limit;
        document.getElementById("tColor1").value = arr[0].color;
        document.getElementById("tColor2").value = arr[1].color;
        document.getElementById("tColor3").value = arr[2].color;
        document.getElementById("tColor4").value = arr[3].color;
      } catch(e) {}
    }

    function applyGpsColorScale() {
      const limits = [
        parseFloat(document.getElementById("gLimit1").value) || 5,
        parseFloat(document.getElementById("gLimit2").value) || 10,
        parseFloat(document.getElementById("gLimit3").value) || 20,
        parseFloat(document.getElementById("gLimit4").value) || 40
      ];
      const cols = [
        document.getElementById("gColor1").value || "#00ff00",
        document.getElementById("gColor2").value || "#ffff00",
        document.getElementById("gColor3").value || "#ff9900",
        document.getElementById("gColor4").value || "#ff0000"
      ];
      gGpsColorScale = [
        { limit: limits[0], color: cols[0] },
        { limit: limits[1], color: cols[1] },
        { limit: limits[2], color: cols[2] },
        { limit: limits[3], color: cols[3] }
      ];
      localStorage.setItem(STORAGE_KEY_GCOL, JSON.stringify(gGpsColorScale));
      logInfo("GPS色スケールを保存しました。");
      updateTecLegend();
      requestDraw();
    }

    function resetGpsColorScale() {
      gGpsColorScale = [
        { limit: 5,  color: "#00ff00" },
        { limit: 10, color: "#ffff00" },
        { limit: 20, color: "#ff9900" },
        { limit: 40, color: "#ff0000" }
      ];
      document.getElementById("gLimit1").value = 5;
      document.getElementById("gLimit2").value = 10;
      document.getElementById("gLimit3").value = 20;
      document.getElementById("gLimit4").value = 40;
      document.getElementById("gColor1").value = "#00ff00";
      document.getElementById("gColor2").value = "#ffff00";
      document.getElementById("gColor3").value = "#ff9900";
      document.getElementById("gColor4").value = "#ff0000";
      localStorage.setItem(STORAGE_KEY_GCOL, JSON.stringify(gGpsColorScale));
      updateTecLegend();
      requestDraw();
    }

    function loadGpsColorScaleFromStorage() {
      const s = localStorage.getItem(STORAGE_KEY_GCOL);
      if (!s) return;
      try {
        const arr = JSON.parse(s);
        if (!Array.isArray(arr) || arr.length !== 4) return;
        gGpsColorScale = arr;
        document.getElementById("gLimit1").value = arr[0].limit;
        document.getElementById("gLimit2").value = arr[1].limit;
        document.getElementById("gLimit3").value = arr[2].limit;
        document.getElementById("gLimit4").value = arr[3].limit;
        document.getElementById("gColor1").value = arr[0].color;
        document.getElementById("gColor2").value = arr[1].color;
        document.getElementById("gColor3").value = arr[2].color;
        document.getElementById("gColor4").value = arr[3].color;
      } catch(e) {}
    }

    /* ============================
     *  NOAA Kp パーサ（強化版）そのまま
     * ============================ */
    function parseKpText(raw) {
      const text = String(raw || "");
      if (/NOAA Kp index breakdown/i.test(text)) return parseKpFrom3DayBreakdown(text);
      if (/NOAA Kp index forecast/i.test(text)) {
        const s2 = parseKpFromGeomagForecastTable(text);
        if (s2.length) return s2;
      }
      return parseKpGenericLine(text);
    }

    function parseKpGenericLine(text) {
      const lines = text.split(/\r?\n/);
      const out = [];
      for (const line of lines) {
        const m = line.match(/(\d{4})[\/\-\s](\d{1,2})[\/\-\s](\d{1,2})[T\s]+(\d{1,2})/);
        if (!m) continue;

        const y  = parseInt(m[1],10);
        const mo = parseInt(m[2],10);
        const d  = parseInt(m[3],10);
        const hh = parseInt(m[4],10);

        const tokens = line.trim().split(/\s+/);
        if (!tokens.length) continue;
        const kpToken = tokens[tokens.length-1];

        let kp = null;
        let m3 = kpToken.match(/^(\d+(\.\d+)?)/);
        if (m3) kp = parseFloat(m3[1]);
        else {
          const m4 = kpToken.match(/^([0-9])([\-+o]?)$/i);
          if (m4) {
            kp = parseInt(m4[1],10);
            const sfx = m4[2];
            if (sfx === "+") kp += 0.33;
            else if (sfx === "-") kp -= 0.33;
          }
        }
        if (kp === null || isNaN(kp)) continue;

        const t = new Date(Date.UTC(y, mo-1, d, hh, 0, 0));
        out.push({ time: t, kp: kp });
      }
      out.sort((a,b) => a.time - b.time);
      return out;
    }

    function parseKpFrom3DayBreakdown(raw) {
      const lines = raw.split(/\r?\n/);
      const out = [];
      const monthMap = { Jan:0, Feb:1, Mar:2, Apr:3, May:4, Jun:5, Jul:6, Aug:7, Sep:8, Oct:9, Nov:10, Dec:11 };

      let idxBreak = -1;
      for (let i=0;i<lines.length;i++) if (/NOAA Kp index breakdown/i.test(lines[i])) { idxBreak = i; break; }
      if (idxBreak < 0) return out;

      let year = null;
      const mYear = lines[idxBreak].match(/(\d{4})\s*$/);
      if (mYear) year = parseInt(mYear[1],10);

      let headerLine = null;
      let headerIndex = -1;
      for (let i=idxBreak+1;i<lines.length;i++) {
        const ln = lines[i].trim();
        if (!ln) continue;
        if (/[A-Za-z]{3}\s+\d{1,2}/.test(ln)) { headerLine = lines[i]; headerIndex = i; break; }
      }
      if (!headerLine || year === null) return out;

      const headerTokens = headerLine.trim().split(/\s+/);
      if (headerTokens.length % 2 !== 0) return out;

      const colDates = [];
      for (let i=0;i<headerTokens.length;i+=2) {
        const mon = headerTokens[i];
        const day = parseInt(headerTokens[i+1],10);
        const mi  = monthMap[mon] !== undefined ? monthMap[mon] : monthMap[String(mon).slice(0,3)];
        if (mi === undefined || isNaN(day)) continue;
        colDates.push(new Date(Date.UTC(year, mi, day, 0, 0, 0)));
      }
      if (!colDates.length) return out;

      const patUT = /^\s*(\d{2})-(\d{2})UT/;
      for (let i=headerIndex+1;i<lines.length;i++) {
        const line = lines[i];
        const m = line.match(patUT);
        if (!m) continue;

        const startHour = parseInt(m[1],10);
        const tokens = line.trim().split(/\s+/);
        if (tokens.length < 1 + colDates.length) continue;

        for (let c=0;c<colDates.length;c++) {
          const vStr = tokens[1+c];
          const kpVal = parseFloat(vStr);
          if (!isNaN(kpVal)) {
            const baseDate = colDates[c];
            const t = new Date(Date.UTC(
              baseDate.getUTCFullYear(),
              baseDate.getUTCMonth(),
              baseDate.getUTCDate(),
              startHour, 0, 0
            ));
            out.push({ time: t, kp: kpVal });
          }
        }
      }
      out.sort((a,b) => a.time - b.time);
      return out;
    }

    function parseKpFromGeomagForecastTable(raw) {
      const lines = raw.split(/\r?\n/);
      const out = [];
      const monthMap = { Jan:0, Feb:1, Mar:2, Apr:3, May:4, Jun:5, Jul:6, Aug:7, Sep:8, Oct:9, Nov:10, Dec:11 };

      let year = null;
      for (const ln of lines) {
        const m = ln.match(/:Issued:\s*(\d{4})\s+([A-Za-z]{3})\s+(\d{1,2})/);
        if (m) { year = parseInt(m[1],10); break; }
      }
      if (!year) year = new Date().getUTCFullYear();

      let idx = -1;
      for (let i=0;i<lines.length;i++) if (/NOAA Kp index forecast/i.test(lines[i])) { idx = i; break; }
      if (idx < 0) return out;

      let headerLine = null;
      for (let i=idx; i<Math.min(lines.length, idx+12); i++) {
        const ln = lines[i].trim();
        if (!ln) continue;
        if (/(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+\d{1,2}/.test(ln) && !/UT/.test(ln)) { headerLine = ln; break; }
      }
      if (!headerLine) return out;

      const toks = headerLine.trim().split(/\s+/);
      if (toks.length < 4 || toks.length % 2 !== 0) return out;

      const days = [];
      for (let k=0;k<toks.length;k+=2) {
        const mon = toks[k];
        const day = parseInt(toks[k+1],10);
        const mi  = monthMap[mon] ?? monthMap[String(mon).slice(0,3)];
        if (mi === undefined || isNaN(day)) continue;
        days.push(new Date(Date.UTC(year, mi, day, 0, 0, 0)));
      }
      if (!days.length) return out;

      const rowRe = /^\s*(\d{2})-(\d{2})UT\s+(.+)$/;
      for (const lnRaw of lines) {
        const m = lnRaw.match(rowRe);
        if (!m) continue;
        const startHour = parseInt(m[1],10);
        const rest = m[3].trim().split(/\s+/);
        if (rest.length < days.length) continue;

        for (let c=0;c<days.length;c++) {
          const v = parseFloat(rest[c]);
          if (!isNaN(v)) {
            const baseDate = days[c];
            const t = new Date(Date.UTC(
              baseDate.getUTCFullYear(),
              baseDate.getUTCMonth(),
              baseDate.getUTCDate(),
              startHour, 0, 0
            ));
            out.push({ time: t, kp: v });
          }
        }
      }
      out.sort((a,b)=>a.time-b.time);
      return out;
    }

    /* ============================
     *  NOAA/Swpc time_tag → UTC Date
     * ============================ */
    function toUtcDateFromSwpcTimeTag(s) {
      const t = String(s || "").trim();
      if (!t) return null;

      // "2025-11-26 00:00:00.000"
      let m = t.match(/^(\d{4})-(\d{2})-(\d{2})\s+(\d{2}):(\d{2})(?::(\d{2}))?/);
      if (m) {
        const y=+m[1], mo=+m[2], d=+m[3], hh=+m[4], mm=+m[5], ss=+(m[6]||0);
        return new Date(Date.UTC(y,mo-1,d,hh,mm,ss));
      }

      // ISO
      const d2 = new Date(t);
      if (!isNaN(d2.getTime())) return d2;
      return null;
    }

    /* ============================
     *  Kp / Flare series parse
     * ============================ */
    function parseBaseKpJsonSeries() {
      const ta = document.getElementById("baseKpJson");
      const raw = ta ? ta.value : "";
      if (!raw.trim()) return [];

      try {
        const js = JSON.parse(raw);
        if (!Array.isArray(js) || js.length < 2) return [];
        const out = [];
        for (let i=1;i<js.length;i++) {
          const row = js[i];
          if (!Array.isArray(row) || row.length < 2) continue;
          const t = toUtcDateFromSwpcTimeTag(row[0]);
          const kp = parseFloat(row[1]);
          if (t && isFinite(kp)) out.push({ time: t, kp });
        }
        out.sort((a,b)=>a.time-b.time);
        return out;
      } catch(e) {
        console.warn("BaseKp JSON parse failed:", e);
        return [];
      }
    }

    function parseBaseFlareJsonSeries() {
      const ta = document.getElementById("baseFlareJson");
      const raw = ta ? ta.value : "";
      if (!raw.trim()) return [];
      try {
        const js = JSON.parse(raw);
        if (!Array.isArray(js)) return [];
        const out = [];
        for (const r of js) {
          const t = toUtcDateFromSwpcTimeTag(r.time);
          const Px = parseFloat(r.Px);
          const Pm = parseFloat(r.Pm);
          if (t && (isFinite(Px) || isFinite(Pm))) out.push({ time: t, Px: isFinite(Px)?Px:0, Pm: isFinite(Pm)?Pm:0 });
        }
        out.sort((a,b)=>a.time-b.time);
        return out;
      } catch(e) {
        console.warn("BaseFlare JSON parse failed:", e);
        return [];
      }
    }

    /* ============================
     *  ★日周（UTC時刻-of-day）用：前処理＆線形補間
     * ============================ */
    function minuteOfDayUTC(t){
      return t.getUTCHours()*60 + t.getUTCMinutes() + t.getUTCSeconds()/60;
    }

    function buildTodLinearSeriesKp(seriesAbs){
      if (!seriesAbs || !seriesAbs.length) return null;
      const pts = [];
      for (const p of seriesAbs){
        if (!p?.time || !isFinite(p.kp)) continue;
        pts.push({ m: minuteOfDayUTC(p.time), v: p.kp });
      }
      if (!pts.length) return null;
      pts.sort((a,b)=>a.m-b.m);

      const mins = pts.map(p=>p.m);
      const vals = pts.map(p=>p.v);

      const compactM=[], compactV=[];
      for (let i=0;i<mins.length;i++){
        if (compactM.length && Math.abs(compactM[compactM.length-1]-mins[i])<1e-9){
          compactV[compactV.length-1]=vals[i];
        } else {
          compactM.push(mins[i]);
          compactV.push(vals[i]);
        }
      }
      return { mins: compactM, vals: compactV };
    }

    function buildTodLinearSeriesFlare(seriesAbs){
      if (!seriesAbs || !seriesAbs.length) return null;
      const pts = [];
      for (const p of seriesAbs){
        if (!p?.time) continue;
        const m = minuteOfDayUTC(p.time);
        pts.push({ m, Px: isFinite(p.Px)?p.Px:0, Pm: isFinite(p.Pm)?p.Pm:0 });
      }
      if (!pts.length) return null;
      pts.sort((a,b)=>a.m-b.m);

      const mins=[], pxs=[], pms=[];
      for (const p of pts){
        if (mins.length && Math.abs(mins[mins.length-1]-p.m)<1e-9){
          pxs[pxs.length-1]=p.Px; pms[pms.length-1]=p.Pm;
        } else {
          mins.push(p.m); pxs.push(p.Px); pms.push(p.Pm);
        }
      }
      return { mins, Px: pxs, Pm: pms };
    }

    function interpTodLinear(tod, minute){
      if (!tod || !tod.mins?.length) return null;
      const mins = tod.mins, vals = tod.vals;
      const m = ((minute % 1440) + 1440) % 1440;

      if (mins.length === 1) return vals[0];

      let lo=0, hi=mins.length-1;
      while (lo<=hi){
        const mid=(lo+hi)>>1;
        if (mins[mid] <= m) lo = mid+1;
        else hi = mid-1;
      }
      let i0 = hi;
      let i1 = lo;

      if (i0 < 0) { i0 = mins.length-1; }
      if (i1 >= mins.length) { i1 = 0; }

      const m0 = mins[i0];
      const m1 = mins[i1];

      if (Math.abs(m1-m0) < 1e-9) return vals[i0];

      let dt = m1 - m0;
      let dm = m - m0;
      if (dt < 0) dt += 1440;
      if (dm < 0) dm += 1440;

      const w = clamp(dm/dt, 0, 1);
      return vals[i0] + (vals[i1] - vals[i0]) * w;
    }

    function interpTodLinear2(tod, minute){
      if (!tod || !tod.mins?.length) return {Px:0,Pm:0};
      const mins = tod.mins;
      const Px = tod.Px;
      const Pm = tod.Pm;
      const m = ((minute % 1440) + 1440) % 1440;

      if (mins.length === 1) return {Px:Px[0], Pm:Pm[0]};

      let lo=0, hi=mins.length-1;
      while (lo<=hi){
        const mid=(lo+hi)>>1;
        if (mins[mid] <= m) lo = mid+1;
        else hi = mid-1;
      }
      let i0 = hi;
      let i1 = lo;
      if (i0 < 0) i0 = mins.length-1;
      if (i1 >= mins.length) i1 = 0;

      const m0 = mins[i0], m1 = mins[i1];
      if (Math.abs(m1-m0)<1e-9) return {Px:Px[i0], Pm:Pm[i0]};

      let dt = m1 - m0;
      let dm = m - m0;
      if (dt < 0) dt += 1440;
      if (dm < 0) dm += 1440;
      const w = clamp(dm/dt, 0, 1);

      return {
        Px: Px[i0] + (Px[i1]-Px[i0])*w,
        Pm: Pm[i0] + (Pm[i1]-Pm[i0])*w
      };
    }

    /* ============================
     *  NOAA 12枚（2h）→ 30分へ格子線形補間（UTC時刻-of-day）
     * ============================ */
    function getNoaaGridAtTimeUTC(t){
      if (!gNoaaDayFrames || !gNoaaDayFrames.length) return null;
      const m = minuteOfDayUTC(t);
      const idx0 = Math.floor(m / 120) % 12;
      const idx1 = (idx0 + 1) % 12;
      const m0 = idx0 * 120;
      const m1 = (idx1 * 120) % 1440;

      let dt = m1 - m0;
      let dm = m - m0;
      if (dt <= 0) dt += 1440;
      if (dm < 0) dm += 1440;
      const w = clamp(dm / dt, 0, 1);

      const f0 = gNoaaDayFrames[idx0];
      const f1 = gNoaaDayFrames[idx1];
      if (!f0 || !f1) return null;

      return mixGrids(f0.grid, f1.grid, w);
    }

    function mixGrids(g0, g1, w){
      const nLat = g0.length;
      const nLon = g0[0].length;
      const out = Array.from({length:nLat}, ()=>Array.from({length:nLon}, ()=>0));
      for (let i=0;i<nLat;i++){
        for (let j=0;j<nLon;j++){
          const a = g0[i][j];
          const b = g1[i][j];
          const va = isFinite(a) ? a : 0;
          const vb = isFinite(b) ? b : 0;
          out[i][j] = va + (vb - va) * w;
        }
      }
      return out;
    }

    /* ============================
     *  BoM 9枚 → 絶対時刻で補間（30分）
     * ============================ */
    function getBomGridAtTimeUTC(t, bomFrames){
      if (!bomFrames || !bomFrames.length) return null;
      bomFrames = bomFrames.slice().sort((a,b)=>a.time-b.time);

      if (t <= bomFrames[0].time) return bomFrames[0].grid;
      if (t >= bomFrames[bomFrames.length-1].time) return bomFrames[bomFrames.length-1].grid;

      let k=1;
      while (k < bomFrames.length && bomFrames[k].time < t) k++;
      const a = bomFrames[k-1], b = bomFrames[k];
      const dt = (b.time - a.time);
      const w = clamp((t - a.time)/dt, 0, 1);
      return mixGrids(a.grid, b.grid, w);
    }

    /* =========================================================
     *  SStorm (Mukhtarovベース + スーパーストームtail) 実装
     * =========================================================
     *  【要件固定：簡易版禁止】
     *
     *  rStorm(Kp, φ, month) = 1 + rTEC(Kp, φ, month)
     *
     *  rTEC は「基底3ケースの多項式を、緯度差×季節差のガウス重みでブレンド」したもの + tail
     *
     *  基底（basis）:
     *   - July_40S: latAbs=40, month=7,
     *     a=[-0.0742756961, 0.08331505314, -0.01888613709, 0.002074999214]
     *   - Nov_40N:  latAbs=40, month=11,
     *     a=[-0.1106197275, 0.1320345523, -0.04870525828, 0.005143845605]
     *   - Nov_70N:  latAbs=70, month=11,
     *     a=[-0.3746087246, 0.3563156192, -0.09425770425, 0.007924840841]
     *
     *  ガウス重み:
     *   σ_lat = 15.0 [deg], σ_m=2.0[month]
     *   w_i = exp(-0.5*(Δlat/σ_lat)^2) * exp(-0.5*(Δm/σ_m)^2)
     *   Δm は cyclic（月差の最小値）で計算
     *   南半球は季節を 6ヶ月シフト: monthSeason=(month+6) mod 12（1..12に戻す）
     *
     *  多項式:
     *   poly_i(Kp) = a0 + a1*Kp + a2*Kp^2 + a3*Kp^3
     *   rTEC_base = Σ (w_i/sumW) * poly_i(Kp)
     *
     *  スーパーストームtail:
     *   Kc=6.5, w=1.2, A0=0.01
     *   baseAtKc = rTEC_base(Kc)
     *   A = A0 * (1 + max(baseAtKc, 0))
     *   L = 1/(1+exp(-(Kp-Kc)/w))
     *   dK=max(0,Kp-Kc)
     *   tail = A * L * dK^2
     *   rTEC = rTEC_base + tail
     *   rStorm = 1 + rTEC
     *
     *  インターフェース固定:
     *   - sstormPos_rTEC(Kp, latDeg, month, options)
     *   - sstormPos_rStorm(Kp, latDeg, month, options)
     *   options: sigmaLat, sigmaM, useTail, Kc, w, A0 を上書き可
     * ========================================================= */

    const SSTORM_BASIS = [
      { name:"July_40S", latAbs:40, month:7,  a:[-0.0742756961, 0.08331505314, -0.01888613709, 0.002074999214] },
      { name:"Nov_40N",  latAbs:40, month:11, a:[-0.1106197275, 0.1320345523, -0.04870525828, 0.005143845605] },
      { name:"Nov_70N",  latAbs:70, month:11, a:[-0.3746087246, 0.3563156192, -0.09425770425, 0.007924840841] },
    ];

    function _cyclicMonthDiff(m1, m2){
      // m1,m2: 1..12
      let d = Math.abs((m1|0) - (m2|0));
      d = Math.min(d, 12 - d);
      return d;
    }

    function _shiftMonth6(month){
      // month:1..12 -> (month+6) mod 12 (1..12)
      const m0 = (( (month|0) - 1 + 6) % 12 + 12) % 12;
      return m0 + 1;
    }

    function _polyKp(a, kp){
      const k = kp;
      return a[0] + a[1]*k + a[2]*k*k + a[3]*k*k*k;
    }

    function _sstorm_rTEC_base_only(Kp, latDeg, month, options){
      const sigmaLat = (options?.sigmaLat ?? 15.0);
      const sigmaM   = (options?.sigmaM   ?? 2.0);

      const latAbs = Math.abs(latDeg);
      const month0 = (month|0);
      const monthSeason = (latDeg < 0) ? _shiftMonth6(month0) : month0;

      let sumW = 0;
      let acc = 0;

      for (const b of SSTORM_BASIS){
        const dLat = Math.abs(latAbs - b.latAbs);
        const dM   = _cyclicMonthDiff(monthSeason, b.month);

        const wLat = Math.exp(-0.5 * (dLat/sigmaLat) * (dLat/sigmaLat));
        const wM   = Math.exp(-0.5 * (dM/sigmaM)     * (dM/sigmaM));
        const w = wLat * wM;

        const p = _polyKp(b.a, Kp);
        sumW += w;
        acc  += w * p;
      }

      if (sumW <= 0){
        // 理論上ほぼ起きないが保険：等重み
        let s=0;
        for (const b of SSTORM_BASIS) s += _polyKp(b.a, Kp);
        return s / SSTORM_BASIS.length;
      }
      return acc / sumW;
    }

    function sstormPos_rTEC(Kp, latDeg, month, options){
      const opt = options || {};
      const useTail = (opt.useTail ?? true);

      const Kc = (opt.Kc ?? 6.5);
      const w  = (opt.w  ?? 1.2);
      const A0 = (opt.A0 ?? 0.01);

      const rTEC_base = _sstorm_rTEC_base_only(Kp, latDeg, month, opt);

      if (!useTail) return rTEC_base;

      const baseAtKc = _sstorm_rTEC_base_only(Kc, latDeg, month, opt);
      const A = A0 * (1 + Math.max(baseAtKc, 0));
      const L = 1 / (1 + Math.exp(-(Kp - Kc) / w));
      const dK = Math.max(0, Kp - Kc);
      const tail = A * L * dK * dK;

      return rTEC_base + tail;
    }

    function sstormPos_rStorm(Kp, latDeg, month, options){
      return 1 + sstormPos_rTEC(Kp, latDeg, month, options);
    }

    /* ============================
     *  ΔFlare（要件式）
     * ============================ */
    function daySide01(latDeg, lonDeg, tUtc){
      // 簡易DaySide：太陽直下点(subsolar lon)を UT から近似
      // 12:00 UTC -> subLon ≈ 0 deg, 00:00 UTC -> subLon ≈ 180 deg
      const ut = tUtc.getUTCHours() + tUtc.getUTCMinutes()/60 + tUtc.getUTCSeconds()/3600;
      let subLon = 180 - 15*ut; // deg
      subLon = ((subLon + 180) % 360) - 180;

      let dLon = lonDeg - subLon;
      dLon = ((dLon + 180) % 360) - 180;

      // |hour angle| < 90 -> day
      return (Math.abs(dLon) < 90) ? 1 : 0;
    }

    function flareDeltaTECU_req(Px, Pm, daySide, cfg){
      // ΔFlare_forecast = min(15, 15*β_flare*[kX*(Px/100)+kM*(Pm/100)]*DaySide )
      const x = clamp((Px||0)/100, 0, 1);
      const m = clamp((Pm||0)/100, 0, 1);
      const raw = 15.0 * (cfg.betaFlare||0) * ((cfg.kX||0)*x + (cfg.kM||0)*m) * (daySide||0);
      return Math.min(15.0, Math.max(0, raw));
    }

    function readDeepFlareInputs(){
      let sumX=0, sumM=0, n=0;
      for (let i=1;i<=9;i++){
        const use = document.getElementById("fu"+i)?.checked;
        if (!use) continue;
        const px = parseFloat(document.getElementById("fx"+i)?.value)||0;
        const pm = parseFloat(document.getElementById("fm"+i)?.value)||0;
        sumX += px; sumM += pm; n++;
      }
      if (!n) return {Px:0,Pm:0};
      return {Px: sumX/n, Pm: sumM/n};
    }

    /* ============================
     *  Kp 予報の補間（絶対時刻）
     * ============================ */
    function interpKpAbs(series, t){
      if (!series || !series.length) return null;
      series = series.slice().sort((a,b)=>a.time-b.time);
      if (t <= series[0].time) return series[0].kp;
      if (t >= series[series.length-1].time) return series[series.length-1].kp;

      let k=1;
      while (k < series.length && series[k].time < t) k++;
      const a=series[k-1], b=series[k];
      const w=clamp((t-a.time)/(b.time-a.time),0,1);
      return a.kp + (b.kp-a.kp)*w;
    }

    /* ============================
     *  BaseKp / BaseFlare（日周リピート＋線形補間）
     * ============================ */
    function getBaseKpAtTime(t){
      if (!gBaseKpTod) return null;
      return interpTodLinear(gBaseKpTod, minuteOfDayUTC(t));
    }

    function getBaseFlareAtTime(t){
      if (!gBaseFlareTod) return {Px:0,Pm:0};
      return interpTodLinear2(gBaseFlareTod, minuteOfDayUTC(t));
    }

    /* ============================
     *  予報スタート候補
     * ============================ */
    function fillForecastStartCandidates(){
      const sel = document.getElementById("forecastStartSelect");
      if (!sel) return;

      const tecSource = document.getElementById("tecSourceSelect")?.value || "bom";
      let candidates = [];

      if (tecSource === "noaa") {
        if (gNoaaDayTimes && gNoaaDayTimes.length){
          candidates.push(new Date(gNoaaDayTimes[0].getTime()));
        } else {
          const t0 = gNoaaInputTimes?.find(x=>x instanceof Date && !isNaN(x.getTime()));
          if (t0) candidates.push(new Date(t0.getTime()));
        }
      } else {
        const ids = NOAA_INPUT_IDS;
        for (const id of ids){
          const txt = document.getElementById(id)?.value || "";
          if (!txt.trim()) continue;
          const vt = parseBomValidTime(txt);
          if (vt) candidates.push(vt);
        }
      }

      candidates = candidates
        .filter(d=>d instanceof Date && !isNaN(d.getTime()))
        .sort((a,b)=>a-b);

      sel.innerHTML = "";
      if (!candidates.length){
        const opt = document.createElement("option");
        opt.value = "";
        opt.textContent = "（候補なし：入力TECを読み込んでください）";
        sel.appendChild(opt);
        return;
      }

      for (const d of candidates){
        const opt = document.createElement("option");
        opt.value = d.toISOString();
        opt.textContent = d.toISOString().replace(".000Z","Z");
        sel.appendChild(opt);
      }

      sel.value = candidates[0].toISOString();
      document.getElementById("forecastStartInfo").textContent =
        "候補から選択済み: " + candidates[0].toISOString().replace(".000Z","Z");
    }

    /* ============================
     *  地域フォーカス
     * ============================ */
    function focusRegion(name){
      if (!map) return;
      const regions = {
        japan:        [[20,120],[50,150]],
        northAmerica: [[10,-130],[60,-60]],
        southAmerica: [[-55,-85],[15,-30]],
        europe:       [[30,-15],[70,40]],
        africa:       [[-35,-20],[35,55]],
        australia:    [[-45,110],[-5,160]],
      };
      const b = regions[name];
      if (!b) return;
      map.fitBounds([b[0], b[1]]);
    }
    function applyManualFocus(){
      if (!map) return;
      const la0 = parseFloat(document.getElementById("focusLatMin").value)||-10;
      const la1 = parseFloat(document.getElementById("focusLatMax").value)||50;
      const lo0 = parseFloat(document.getElementById("focusLonMin").value)||120;
      const lo1 = parseFloat(document.getElementById("focusLonMax").value)||150;
      map.fitBounds([[la0,lo0],[la1,lo1]]);
    }
    function resetFocus(){
      if (!map) return;
      map.setView([15, 0], 2);
    }

    /* ============================
     *  凡例（TEC/GPS）
     * ============================ */
    function hexToRgb(h){
      const s = String(h||"").replace("#","");
      if (s.length===3){
        const r=parseInt(s[0]+s[0],16), g=parseInt(s[1]+s[1],16), b=parseInt(s[2]+s[2],16);
        return {r,g,b};
      }
      if (s.length!==6) return {r:255,g:255,b:255};
      const r=parseInt(s.slice(0,2),16), g=parseInt(s.slice(2,4),16), b=parseInt(s.slice(4,6),16);
      return {r,g,b};
    }
    function rgbToHex(r,g,b){
      const h = (x)=>String(clamp(Math.round(x),0,255).toString(16)).padStart(2,"0");
      return "#"+h(r)+h(g)+h(b);
    }

    function colorForValueContinuous(v, scale){
      if (!isFinite(v)) return "rgba(0,0,0,0)";
      const s = scale.slice().sort((a,b)=>a.limit-b.limit);
      if (v <= s[0].limit) return s[0].color;

      for (let i=1;i<s.length;i++){
        if (v <= s[i].limit){
          const a = s[i-1], b = s[i];
          const w = clamp((v - a.limit) / (b.limit - a.limit), 0, 1);
          const A = hexToRgb(a.color), B = hexToRgb(b.color);
          return rgbToHex(A.r+(B.r-A.r)*w, A.g+(B.g-A.g)*w, A.b+(B.b-A.b)*w);
        }
      }
      return s[s.length-1].color;
    }

    function updateTecLegend(){
      if (!tecLegendControl) return;
      tecLegendControl.remove();
      tecLegendControl = buildLegendControl();
      tecLegendControl.addTo(map);
    }

    function buildLegendControl(){
      const ctrl = L.control({position:"bottomright"});
      ctrl.onAdd = function(){
        const div = L.DomUtil.create("div","leaflet-control tec-legend");

        const title = document.createElement("div");
        title.className="tec-legend-title";
        title.textContent = (mapMode==="tec") ? "TEC [TECU]" : "GPS L1 err [m]";
        div.appendChild(title);

        const bar = document.createElement("div");
        bar.className="tec-legend-bar";

        const scale = (mapMode==="tec") ? gTecColorScale : gGpsColorScale;
        const s = scale.slice().sort((a,b)=>a.limit-b.limit);
        const gradStops = [];
        for (let i=0;i<s.length;i++){
          const pct = (i/(s.length-1))*100;
          gradStops.push(`${s[i].color} ${pct}%`);
        }
        bar.style.background = `linear-gradient(to top, ${gradStops.join(",")})`;
        div.appendChild(bar);

        const labels = document.createElement("div");
        labels.className="tec-legend-labels";
        labels.innerHTML = `<span>0</span><span>${s[s.length-1].limit}</span>`;
        div.appendChild(labels);

        return div;
      };
      return ctrl;
    }

    /* ============================
     *  Map init + Canvas overlay
     * ============================ */
    function initMap(){
      map = L.map("tecMap", { preferCanvas: true }).setView([15,0], 2);
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 8, attribution: "&copy; OpenStreetMap"
      }).addTo(map);

      const container = map.getContainer();
      tecCanvas = document.createElement("canvas");
      tecCanvas.className = "tec-canvas-overlay";
      container.appendChild(tecCanvas);
      tecCtx = tecCanvas.getContext("2d", { alpha: true });

      resizeCanvasToMap();

      map.on("resize", ()=>{ resizeCanvasToMap(); invalidateProjCache(); requestDraw(); });
      map.on("zoomend moveend", ()=>{ invalidateProjCache(); requestDraw(); });

      map.on("click", (ev)=>{ onMapClick(ev.latlng); });

      tecLegendControl = buildLegendControl();
      tecLegendControl.addTo(map);
    }

    function resizeCanvasToMap(){
      const c = map.getContainer();
      tecCanvas.width  = c.clientWidth;
      tecCanvas.height = c.clientHeight;
    }

    /* ============================
     *  ★投影キャッシュ（lat/lon→pixel）で描画を高速化
     * ============================ */
    let gProjCache = null;
    function invalidateProjCache(){ gProjCache = null; }

    function ensureProjCache(){
      if (!gGrid || !map) return null;

      const w = tecCanvas.width, h = tecCanvas.height;
      const z = map.getZoom();
      const key = `${w}x${h}@z${z}`;

      if (gProjCache && gProjCache.key === key) return gProjCache;

      const latArr = gGrid.latArr;
      const lonArr = gGrid.lonArr;
      const nLat = gGrid.nLat;
      const nLon = gGrid.nLon;

      const dLat = (nLat>1) ? (latArr[1]-latArr[0]) : 2;
      const dLon = (nLon>1) ? (lonArr[1]-lonArr[0]) : 5;

      const latEdge = new Array(nLat+1);
      const lonEdge = new Array(nLon+1);

      for (let i=0;i<=nLat;i++){
        if (i===0) latEdge[i] = latArr[0] - dLat/2;
        else if (i===nLat) latEdge[i] = latArr[nLat-1] + dLat/2;
        else latEdge[i] = (latArr[i-1]+latArr[i])/2;
      }
      for (let j=0;j<=nLon;j++){
        if (j===0) lonEdge[j] = lonArr[0] - dLon/2;
        else if (j===nLon) lonEdge[j] = lonArr[nLon-1] + dLon/2;
        else lonEdge[j] = (lonArr[j-1]+lonArr[j])/2;
      }

      const px = Array.from({length:nLat+1}, ()=>new Float32Array(nLon+1));
      const py = Array.from({length:nLat+1}, ()=>new Float32Array(nLon+1));

      for (let i=0;i<=nLat;i++){
        for (let j=0;j<=nLon;j++){
          const p = map.latLngToContainerPoint([latEdge[i], lonEdge[j]]);
          px[i][j] = p.x;
          py[i][j] = p.y;
        }
      }

      gProjCache = { key, px, py, latEdge, lonEdge };
      return gProjCache;
    }

    /* ============================
     *  描画
     * ============================ */
    function drawTecOverlay(){
      if (!tecCtx || !tecCanvas) return;
      tecCtx.clearRect(0,0,tecCanvas.width, tecCanvas.height);
      if (!gForecastFrames || !gForecastFrames.length || !gGrid) return;

      const step = clamp(currentStepIndex, 0, gForecastFrames.length-1);
      const gridVal = gForecastFrames[step];
      if (!gridVal) return;

      const cfg = getConfigFromUI();
      const scale = (mapMode==="tec") ? gTecColorScale : gGpsColorScale;

      const cache = ensureProjCache();
      if (!cache) return;

      const nLat = gGrid.nLat, nLon = gGrid.nLon;
      const px = cache.px, py = cache.py;

      const alpha = tecAlpha;

      for (let i=0;i<nLat;i++){
        for (let j=0;j<nLon;j++){
          let v = gridVal[i][j];
          if (!isFinite(v)) continue;

          if (mapMode==="gps"){
            v = v * (cfg.kL1||0.16);
          }

          const col = colorForValueContinuous(v, scale);
          const x0 = px[i][j],   y0 = py[i][j];
          const x1 = px[i][j+1], y1 = py[i+1][j];
          const w = x1 - x0;
          const h = y1 - y0;
          if (!isFinite(w) || !isFinite(h)) continue;

          tecCtx.globalAlpha = alpha;
          tecCtx.fillStyle = col;
          tecCtx.fillRect(x0, y0, w, h);
        }
      }
      tecCtx.globalAlpha = 1.0;
    }

    function onTecAlphaChange(){
      tecAlpha = parseFloat(document.getElementById("tecAlpha").value) || 0.8;
      requestDraw();
    }

    function changeMapMode(){
      mapMode = document.getElementById("mapModeSelect").value || "tec";
      updateTecLegend();
      requestDraw();
    }

    function onSliderChange(){
      const s = document.getElementById("timeSlider");
      const idx = parseInt(s.value,10) || 0;
      currentStepIndex = clamp(idx, 0, N_STEPS);

      const t = gForecastTimes[currentStepIndex];
      document.getElementById("timeLabel").textContent = `t = ${(currentStepIndex*DT_MINUTES/60).toFixed(1)} h`;
      document.getElementById("utcLabel").textContent  = "UTC: " + (t ? t.toISOString().replace(".000Z","Z") : "--");

      // ★Kpがタイムスライダーに連動（stepLikeでサンプル）→ ラベルと計算が一致
      const kpF = interpKpAbs(gKpSeries, t);
      const kpB = getBaseKpAtTime(t);
      document.getElementById("kpNowLabel").textContent =
        `KpF=${(kpF==null?"--":kpF.toFixed(2))} / KpB=${(kpB==null?"--":kpB.toFixed(2))}`;

      requestDraw();
    }

    /* ============================
     *  計算式表示（要件の形で固定）
     * ============================ */
    function updateFormulaText(){
      const cfg = getConfigFromUI();

      document.getElementById("formulaText").textContent =
`(A) Base 抽出
  TEC_input(φ,λ,t) ≈ BaseTEC(φ,λ,t) * { 1 + kStorm * [ rStorm(Kp_base(t),φ,month(t)) - 1 ] } + ΔFlare_base(φ,λ,t)
  BaseTEC_raw = { TEC_input - ΔFlare_base } / { 1 + kStorm * [ rStorm(Kp_base) - 1 ] }
  BaseTEC = max(0, kBase * BaseTEC_raw)

(B) 予報加算
  TEC_total = BaseTEC + ΔStorm_forecast + ΔFlare_forecast
  ΔStorm_forecast = kStorm * BaseTEC * { rStorm(Kp_forecast(t),φ,month(t)) - 1 }
  ΔFlare_forecast = min(15, 15*β_flare*[kX*(Px/100)+kM*(Pm/100)]*DaySide )

(重要) rStormは倍率。ΔStormは BaseTEC に掛け算してTECU化。rStormをTECUとして足し込むのは禁止。

kBase=${cfg.kBase.toFixed(2)}, kStorm=${cfg.kStorm.toFixed(2)}, β_flare=${cfg.betaFlare.toFixed(2)}, kX=${cfg.kX.toFixed(2)}, kM=${cfg.kM.toFixed(2)}
SStorm options: σ_lat=${cfg.sigmaLat.toFixed(1)}deg, σ_m=${cfg.sigmaM.toFixed(1)}month, tail=${cfg.useTail? "ON":"OFF"} (Kc=${cfg.tailKc.toFixed(2)}, w=${cfg.tailW.toFixed(2)}, A0=${cfg.tailA0.toFixed(3)})`;
    }

    /* ============================
     *  予報計算（4日×30分）
     * ============================ */
    function runForecast(){
      try{
        const tecSource = document.getElementById("tecSourceSelect")?.value || "bom";
        const cfg = getConfigFromUI();
        updateFormulaText();

        // 予報開始時刻
        const sel = document.getElementById("forecastStartSelect");
        let start = null;
        if (sel && sel.value){
          start = new Date(sel.value);
          if (isNaN(start.getTime())) start = null;
        }
        if (!start){
          if (tecSource==="noaa" && gNoaaDayTimes?.length) start = new Date(gNoaaDayTimes[0].getTime());
          else {
            const ids = NOAA_INPUT_IDS;
            for (const id of ids){
              const vt = parseBomValidTime(document.getElementById(id)?.value||"");
              if (vt){ start = vt; break; }
            }
          }
        }
        if (!start) throw new Error("予報開始時刻が決められません（入力TECが空？）");
        gForecastStart = start;

        // 予報時間配列（30分刻み）
        gForecastTimes = [];
        for (let k=0;k<=N_STEPS;k++){
          gForecastTimes.push(new Date(start.getTime() + k*DT_MINUTES*60*1000));
        }

        // Kp予報読み込み
        const kpRaw = document.getElementById("noaaKpText")?.value || "";
        gKpSeries = parseKpText(kpRaw);

        // Base Kp / Base flare（空なら予報流用＆flare=0）
        gBaseKpSeries = parseBaseKpJsonSeries();
        if (!gBaseKpSeries.length && gKpSeries.length) gBaseKpSeries = gKpSeries.slice();
        gBaseFlareSeries = parseBaseFlareJsonSeries(); // 無ければ空

        gBaseKpTod = buildTodLinearSeriesKp(gBaseKpSeries);
        gBaseFlareTod = buildTodLinearSeriesFlare(gBaseFlareSeries);

        // DeepFlare（予報用）
        const flareF = readDeepFlareInputs();

        // 入力格子（NOAA or BoM）
        let inputGridProvider = null; // (t)->grid[][]

        if (tecSource==="noaa"){
          if (!gNoaaDayFrames || !gNoaaDayFrames.length){
            // fallback: textarea（9枚）から読む
            const frames = [];
            for (let i=0;i<9;i++){
              const txt = document.getElementById(NOAA_INPUT_IDS[i])?.value || "";
              if (!txt.trim()) continue;
              const vt = (gNoaaInputTimes && gNoaaInputTimes[i]) ? gNoaaInputTimes[i] : null;
              const fr = parseNoaaGloTecGeoJson(txt, vt, 2.0, 5.0);
              frames.push(fr);
            }
            if (!frames.length) throw new Error("NOAA入力がありません（0番の取得ボタンを押して）");
            gNoaaDayFrames = frames;
            gNoaaDayTimes  = frames.map(f=>f.validTime).filter(Boolean);
          }

          const f0 = gNoaaDayFrames[0];
          gGrid = { latArr: f0.latArr, lonArr: f0.lonArr, nLat: f0.nLat, nLon: f0.nLon };
          inputGridProvider = (t)=>getNoaaGridAtTimeUTC(t);

        } else {
          const frames = [];
          for (let i=0;i<9;i++){
            const txt = document.getElementById(NOAA_INPUT_IDS[i])?.value || "";
            if (!txt.trim()) continue;
            const p = parseBoM(txt);
            frames.push({ time: p.validTime, grid: p.grid, latArr:p.latArr, lonArr:p.lonArr, nLat:p.nLat, nLon:p.nLon });
          }
          if (frames.length < 2) throw new Error("BoM入力が不足（9枚貼るかAPI取得）");

          gGrid = { latArr: frames[0].latArr, lonArr: frames[0].lonArr, nLat: frames[0].nLat, nLon: frames[0].nLon };
          inputGridProvider = (t)=>getBomGridAtTimeUTC(t, frames);
        }

        // 予報フレーム生成
        const nLat = gGrid.nLat, nLon = gGrid.nLon;
        gForecastFrames = Array.from({length:N_STEPS+1}, ()=>Array.from({length:nLat}, ()=>Array.from({length:nLon}, ()=>0)));

        const dbgMix = document.getElementById("dbgNoaaMix")?.checked;

        // SStorm options pack（UI→optionsで上書き）
        const sstormOpt = {
          sigmaLat: cfg.sigmaLat,
          sigmaM: cfg.sigmaM,
          useTail: cfg.useTail,
          Kc: cfg.tailKc,
          w: cfg.tailW,
          A0: cfg.tailA0
        };

        for (let k=0;k<=N_STEPS;k++){
          const t = gForecastTimes[k];
          const month = t.getUTCMonth() + 1;

          const inputGrid = inputGridProvider(t);
          if (!inputGrid) throw new Error("入力TECの補間に失敗（NOAA/BoMの取得状況を確認）");

          // ★stepLikeサンプルは「ラベル表示」と同じ関数（interp）を使う
          const kpF = (interpKpAbs(gKpSeries, t) ?? 3.0);
          const kpB = (getBaseKpAtTime(t) ?? kpF);
          const flareB = getBaseFlareAtTime(t);

          for (let i=0;i<nLat;i++){
            const lat = gGrid.latArr[i];

            // rStormは緯度・月・Kp依存（倍率）
            const rStormB = sstormPos_rStorm(kpB, lat, month, sstormOpt);
            const rStormF = sstormPos_rStorm(kpF, lat, month, sstormOpt);

            // Base抽出用の係数（分母）
            const denom = Math.max(0.05, 1 + (cfg.kStorm||0) * (rStormB - 1)); // 0割・暴走防止

            for (let j=0;j<nLon;j++){
              const lon = gGrid.lonArr[j];
              const inTec = inputGrid[i][j];

              const day = daySide01(lat, lon, t);

              // Flare: base / forecast
              const flareBaseTec = flareDeltaTECU_req(flareB.Px, flareB.Pm, day, cfg);
              const flareForeTec = flareDeltaTECU_req(flareF.Px, flareF.Pm, day, cfg);

              // (A) Base抽出
              const baseTec_raw = (inTec - flareBaseTec) / denom;
              const baseTec = Math.max(0, (cfg.kBase||1.0) * baseTec_raw);

              // (B) 予報加算（倍率→TECU）
              const dStorm = (cfg.kStorm||0) * baseTec * (rStormF - 1);
              const outTec = baseTec + dStorm + flareForeTec;

              gForecastFrames[k][i][j] = Math.max(0, outTec);
            }
          }

          if (k===0 && dbgMix){
            logInfo(
              `runForecast OK: start=${start.toISOString().replace(".000Z","Z")} `
              + `/ KpF0=${kpF.toFixed(2)} KpB0=${kpB.toFixed(2)} `
              + `/ SStorm(tail=${cfg.useTail?"ON":"OFF"}, A0=${cfg.tailA0}, Kc=${cfg.tailKc}, w=${cfg.tailW}) `
              + `/ flareF(Px,Pm)=(${flareF.Px.toFixed(1)},${flareF.Pm.toFixed(1)})`
            );
          }
        }

        // slider設定
        const slider = document.getElementById("timeSlider");
        slider.min = "0";
        slider.max = String(N_STEPS);
        slider.value = "0";
        currentStepIndex = 0;

        invalidateProjCache();
        onSliderChange();
        requestDraw();
      } catch(e){
        console.error(e);
        logInfo("runForecast 失敗: " + e.message);
      }
    }

    /* ============================
     *  地図クリック：最近傍格子
     * ============================ */
    function onMapClick(latlng){
      if (!gGrid || !gForecastFrames?.length) return;
      const lat = latlng.lat;
      let lon = latlng.lng;
      lon = ((lon + 180) % 360) - 180;

      let iBest=0, jBest=0, best=1e99;
      for (let i=0;i<gGrid.nLat;i++){
        const dLat = Math.abs(gGrid.latArr[i]-lat);
        for (let j=0;j<gGrid.nLon;j++){
          let dLon = Math.abs(gGrid.lonArr[j]-lon);
          dLon = Math.min(dLon, 360-dLon);
          const d = dLat + dLon;
          if (d<best){ best=d; iBest=i; jBest=j; }
        }
      }

      const tec = gForecastFrames[currentStepIndex]?.[iBest]?.[jBest];
      const cfg = getConfigFromUI();
      const gps = (isFinite(tec) ? tec*(cfg.kL1||0.16) : NaN);

      document.getElementById("pointInfo").textContent =
`Clicked: lat=${lat.toFixed(2)}, lon=${lon.toFixed(2)}
Nearest grid: lat=${gGrid.latArr[iBest].toFixed(2)}, lon=${gGrid.lonArr[jBest].toFixed(2)}
TEC=${isFinite(tec)?tec.toFixed(1):"--"} TECU
GPS L1 err=${isFinite(gps)?gps.toFixed(2):"--"} m`;
    }

    /* ============================
     *  CSV Export（巨大になるので注意）
     * ============================ */
    function exportTecCsv4day(){
      try{
        if (!gForecastFrames?.length || !gGrid) throw new Error("予報が未計算です");

        const rows = [];
        rows.push(["time_utc","lat","lon","tec_tecu"].join(","));

        for (let k=0;k<gForecastTimes.length;k++){
          const t = gForecastTimes[k].toISOString();
          const frame = gForecastFrames[k];
          for (let i=0;i<gGrid.nLat;i++){
            const lat = gGrid.latArr[i];
            for (let j=0;j<gGrid.nLon;j++){
              const lon = gGrid.lonArr[j];
              const tec = frame[i][j];
              rows.push(`${t},${lat.toFixed(2)},${lon.toFixed(2)},${(isFinite(tec)?tec.toFixed(2):"")}`);
            }
          }
        }

        const blob = new Blob([rows.join("\n")], {type:"text/csv;charset=utf-8"});
        const name = `swifttec_4day_${gForecastStart.toISOString().slice(0,10)}.csv`;
        downloadBlob(blob, name);
        logInfo("CSV出力しました: " + name);
      } catch(e){
        console.error(e);
        logInfo("CSV出力失敗: " + e.message);
      }
    }

    function downloadBlob(blob, filename){
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(()=>URL.revokeObjectURL(url), 2000);
    }

    /* ============================
     *  Reset
     * ============================ */
    function resetAll(){
      gForecastFrames = [];
      gForecastTimes = [];
      currentStepIndex = 0;
      document.getElementById("timeLabel").textContent = "t = 0.0 h";
      document.getElementById("utcLabel").textContent = "UTC: --";
      document.getElementById("kpNowLabel").textContent = "KpF=-- / KpB=--";
      document.getElementById("pointInfo").textContent = "地図上をクリックすると、その格子点のTEC・GPS L1誤差と位置が表示されます。";
      logInfo("リセットしました。");
      invalidateProjCache();
      requestDraw();
    }

    /* ============================
     *  起動処理
     * ============================ */
    function bootstrap(){
      loadBomInputsFromStorage();
      loadTecColorScaleFromStorage();
      loadGpsColorScaleFromStorage();
      loadConfig(true);

      initMap();
      applyTecColorScale();
      applyGpsColorScale();

      renderNoaa12Table();
      fillForecastStartCandidates();

      updateFormulaText();
      requestDraw();
    }
    bootstrap();
  </script>
</body>
</html>
