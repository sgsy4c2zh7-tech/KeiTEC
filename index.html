<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>NOAA GloTEC API 取得検証（3時間ごと）</title>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", sans-serif; padding: 14px; }
    input, select, button { padding: 6px; margin: 4px 0; }
    .row { display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
    pre { background:#111; color:#ddd; padding:12px; border-radius:8px; overflow:auto; }
    .ok { color: #0a0; font-weight: 700; }
    .ng { color: #c00; font-weight: 700; }
  </style>
</head>
<body>
  <h2>NOAA GloTEC API 取得検証（まずは3時間ごと）</h2>

  <div class="row">
    <label>取得日(UTC):
      <input id="day" type="date">
    </label>

    <label>間隔:
      <select id="interval">
        <option value="180" selected>3時間（8枚）</option>
        <option value="30">30分（48枚）</option>
      </select>
    </label>

    <button id="run">一覧取得→選定→ダウンロード</button>
  </div>

  <div id="status"></div>
  <pre id="log"></pre>

<script>
const BASE_DIR = "https://services.swpc.noaa.gov/products/glotec/geojson_2d_urt/";
const INDEX_JSON = BASE_DIR + "geojson_2d_urt.json"; // 失敗することがあるのでHTMLへフォールバック

const $ = (id)=>document.getElementById(id);
const logEl = $("log");
const statusEl = $("status");

function setStatus(msg, ok=null){
  statusEl.textContent = msg;
  statusEl.className = (ok===true) ? "ok" : (ok===false ? "ng" : "");
}
function log(msg){
  logEl.textContent += msg + "\n";
  logEl.scrollTop = logEl.scrollHeight;
}

function toDayKeyUTC(d){
  const y=d.getUTCFullYear(), m=d.getUTCMonth()+1, dd=d.getUTCDate();
  const mm = String(m).padStart(2,"0");
  const ddd = String(dd).padStart(2,"0");
  return `${y}-${mm}-${ddd}`;
}

function basename(p){
  const s = String(p);
  return s.split("/").pop();
}

// 例: glotec_icao_20251217T041500Z.geojson
function parseUtcFromFilename(name){
  const m = String(name).match(/(\d{8})T(\d{6})Z/i);
  if(!m) return null;
  const y=+m[1].slice(0,4), mo=+m[1].slice(4,6), d=+m[1].slice(6,8);
  const hh=+m[2].slice(0,2), mm=+m[2].slice(2,4), ss=+m[2].slice(4,6);
  return new Date(Date.UTC(y,mo-1,d,hh,mm,ss));
}

function extractGeojsonLinksFromHtml(html){
  const out=[];
  const re=/href="([^"]+\.geojson)"/ig;
  let m;
  while((m=re.exec(html))!==null) out.push(m[1]);
  return out;
}

function toAbsoluteUrl(p){
  const s=String(p);
  if(/^https?:\/\//i.test(s)) return s;
  if(s.startsWith("/")) return "https://services.swpc.noaa.gov"+s;
  // filenameのみ/相対のみ想定
  return BASE_DIR + basename(s);
}

async function fetchText(url){
  const r = await fetch(url, { cache: "no-store" });
  if(!r.ok) throw new Error(`HTTP ${r.status} ${url}`);
  return await r.text();
}

async function fetchJson(url){
  const r = await fetch(url, { cache: "no-store" });
  if(!r.ok) throw new Error(`HTTP ${r.status} ${url}`);
  return await r.json();
}

function flattenIndexEntries(idx){
  let arr=[];
  if(Array.isArray(idx)) arr=idx;
  else if(idx && Array.isArray(idx.files)) arr=idx.files;
  else if(idx && Array.isArray(idx.data)) arr=idx.data;
  else if(idx && typeof idx==="object"){
    for(const k of Object.keys(idx)){
      if(Array.isArray(idx[k])) { arr=idx[k]; break; }
    }
  }
  const out=[];
  for(const it of arr){
    if(typeof it==="string") out.push(it);
    else if(it && typeof it==="object"){
      const cand = it.url || it.href || it.path || it.name || it.file || it.filename;
      if(cand) out.push(String(cand));
    }
  }
  return out;
}

async function listGeojsonCandidates(){
  // 1) JSON index
  try{
    const idx = await fetchJson(INDEX_JSON);
    const arr = flattenIndexEntries(idx).filter(x=>String(x).toLowerCase().includes(".geojson"));
    if(arr.length){
      log(`index JSON OK: ${arr.length}件`);
      return arr.map(toAbsoluteUrl);
    }
    log("index JSONは読めたが .geojson が見つからない → HTMLへ");
  }catch(e){
    log("index JSON失敗 → HTMLへ: " + e.message);
  }

  // 2) directory HTML
  const html = await fetchText(BASE_DIR);
  const links = extractGeojsonLinksFromHtml(html);
  log(`directory HTML OK: 抽出 ${links.length}件`);
  return links.map(toAbsoluteUrl);
}

function buildTargets(dayKey, intervalMin){
  const m = dayKey.match(/^(\d{4})-(\d{2})-(\d{2})$/);
  if(!m) throw new Error("日付が未指定 or 形式不正");
  const y=+m[1], mo=+m[2], d=+m[3];
  const start = new Date(Date.UTC(y,mo-1,d,0,0,0));
  const count = Math.round((24*60)/intervalMin);
  const targets=[];
  for(let k=0;k<count;k++){
    targets.push(new Date(start.getTime() + k*intervalMin*60000));
  }
  return targets;
}

function nearestFile(files, tTarget, maxDiffMin){
  const tt=tTarget.getTime();
  let best=null, bestDiff=1e99;
  for(const f of files){
    const diff=Math.abs(f.tUtc.getTime()-tt);
    if(diff<bestDiff){ bestDiff=diff; best=f; }
  }
  if(!best) return null;
  if(bestDiff > maxDiffMin*60*1000) return null;
  return best;
}

async function fetchWithLimit(urls, limit=6){
  const out=new Array(urls.length);
  let i=0;
  async function worker(){
    while(i<urls.length){
      const my=i++;
      const r=await fetch(urls[my], { cache:"no-store" });
      if(!r.ok) throw new Error(`HTTP ${r.status} ${urls[my]}`);
      out[my]=await r.text();
    }
  }
  const ws=[];
  for(let k=0;k<Math.min(limit, urls.length);k++) ws.push(worker());
  await Promise.all(ws);
  return out;
}

// GeoJSONからTECを少しだけ読む（仕様が違う可能性があるので「見つけられる範囲」で）
// 目的：中身も取れてるかの簡易チェック
function sampleTecIntegers(geojsonText, maxN=8){
  const obj = JSON.parse(geojsonText);
  const feats = obj && obj.features;
  if(!Array.isArray(feats) || feats.length===0) return [];
  const res=[];
  for(const f of feats){
    const p = f && f.properties;
    if(!p) continue;

    // よくある候補名を順に探す（違ったら空になる）
    const candidates = ["tec", "TEC", "vtec", "VTEC", "value", "Value"];
    let v = null;
    for(const k of candidates){
      if(p[k] != null){ v = p[k]; break; }
    }
    if(v == null) continue;

    const num = Number(v);
    if(!Number.isFinite(num)) continue;
    res.push(Math.floor(num)); // 小数点以下切り捨て
    if(res.length>=maxN) break;
  }
  return res;
}

$("run").addEventListener("click", async ()=>{
  logEl.textContent = "";
  setStatus("実行中…");
  try{
    const dayKey = $("day").value;         // UTC日
    const intervalMin = parseInt($("interval").value, 10);

    log(`BASE_DIR: ${BASE_DIR}`);
    log(`day(UTC): ${dayKey}`);
    log(`interval: ${intervalMin} min`);

    const candidates = await listGeojsonCandidates();

    // ファイル時刻を読む
    const files = [];
    for(const url of candidates){
      const fn = basename(url);
      const t = parseUtcFromFilename(fn);
      if(!t) continue;
      if(toDayKeyUTC(t) !== dayKey) continue;
      files.push({ fn, tUtc: t, url });
    }
    files.sort((a,b)=>a.tUtc-b.tUtc);

    if(!files.length){
      throw new Error(`指定日(UTC)=${dayKey} のファイルが0件（保持期間外 or 命名規則変更）`);
    }
    log(`指定日の候補: ${files.length}件`);
    log(`最初: ${files[0].fn}`);
    log(`最後: ${files[files.length-1].fn}`);

    const targets = buildTargets(dayKey, intervalMin);

    // 10分更新想定：3時間なら±120分、30分なら±25分くらい
    const maxDiffMin = (intervalMin>=180) ? 120 : 25;

    const picks = targets.map(t => ({
      target: t,
      pick: nearestFile(files, t, maxDiffMin)
    }));

    const miss = picks.filter(x=>!x.pick).length;
    if(miss){
      throw new Error(`最近傍選定失敗: ${miss}/${picks.length}（欠損 or 更新遅延）`);
    }

    log("選定結果（target → picked）:");
    for(const x of picks){
      log(`  ${x.target.toISOString()}  ->  ${x.pick.fn}`);
    }

    const urls = picks.map(x=>x.pick.url);
    log(`\nダウンロード開始: ${urls.length}件`);
    const texts = await fetchWithLimit(urls, 6);
    log("ダウンロード完了");

    // 中身チェック（TECサンプル整数を表示）
    log("\nTECサンプル（各ファイル先頭から最大8個、整数化）:");
    for(let i=0;i<texts.length;i++){
      const smp = sampleTecIntegers(texts[i], 8);
      log(`  [${i}] ${basename(urls[i])} -> ${smp.length ? smp.join(", ") : "(TECフィールド見つからず)"} `);
    }

    setStatus("OK: 一覧取得・選定・ダウンロードまで成功", true);
  }catch(e){
    console.error(e);
    setStatus("NG: " + e.message, false);
    log("\nERROR: " + e.message);
  }
});

// 初期値：UTCの「今日-1日」を入れておく（ローカルTZに引っ張られないようUTCで作る）
(function init(){
  const now = new Date();
  const utcToday = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate(), 0,0,0));
  const prev = new Date(utcToday.getTime() - 24*3600*1000);
  $("day").value = toDayKeyUTC(prev);
})();
</script>
</body>
</html>
